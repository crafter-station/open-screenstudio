# Plan: Revise TECHNICAL_PLAN.md Based on Screen Studio Project Format Research

## Summary

Rewrite the technical plan document to incorporate findings from reverse engineering Screen Studio's `.screenstudio` project format. The research reveals a sophisticated multi-channel recording architecture with separate streams, HLS segmentation, comprehensive input tracking, and JSON-based project configuration.

## User Decisions
- **Project Format**: Own format (`.osp`) - no Screen Studio compatibility needed
- **Recording Strategy**: HLS/fMP4 segmented recording (~2s chunks)
- **Input Tracking**: Full fidelity (~120Hz mouse moves, all clicks, keystrokes)

---

## Files to Modify

| File | Action |
|------|--------|
| `docs/TECHNICAL_PLAN.md` | Complete rewrite with research findings |

---

## Complete Revised TECHNICAL_PLAN.md Content

Below is the complete new content for the technical plan document:

---

```markdown
# Technical Plan

This document outlines the technical architecture, stack decisions, and implementation plan for Open ScreenStudio.

> **Status:** Draft - Open for discussion
> 
> We want your input! Comment on this plan in the GitHub Discussions or open issues for specific concerns.

---

## Table of Contents

- [Stack Decision](#stack-decision)
- [Architecture Overview](#architecture-overview)
- [Project File Format](#project-file-format)
- [Recording System](#recording-system)
- [Input Tracking System](#input-tracking-system)
- [Editing Model](#editing-model)
- [Effects & Animation](#effects--animation)
- [Technology Choices](#technology-choices)
- [Platform APIs](#platform-apis)
- [Project Structure](#project-structure)
- [Key Dependencies](#key-dependencies)
- [Implementation Phases](#implementation-phases)
- [Open Questions](#open-questions)
- [Getting Started (Development)](#getting-started-development)

---

## Stack Decision

After evaluating multiple approaches, we've chosen **Tauri + Rust** for the backend and **React + TypeScript** for the frontend.

### Why Tauri?

| Factor | Tauri | Electron | Native |
|--------|-------|----------|--------|
| **Bundle size** | ~10-15 MB | ~150 MB | ~5-10 MB |
| **Memory usage** | Low (system webview) | High (bundled Chromium) | Lowest |
| **Performance** | Excellent | Good | Best |
| **Cross-platform** | Yes | Yes | Separate codebases |
| **Native API access** | Excellent (Rust) | Limited (Node.js) | Full |
| **Contributor accessibility** | Medium | High | Low |
| **Security** | Excellent | Good | Varies |

### Why Not Electron?

Electron is a valid choice with a huge ecosystem, but for a screen recording app:

1. **Performance matters** - Recording + encoding is CPU intensive
2. **Memory matters** - We're already capturing video, can't afford Chromium overhead
3. **Native APIs** - Screen capture requires deep OS integration that Rust handles better
4. **Bundle size** - Users expect small, focused apps

### Why Not Fully Native?

1. **Maintenance burden** - Two completely separate codebases (Swift + C++)
2. **Contributor pool** - Fewer developers know both Swift and C++
3. **UI consistency** - Harder to maintain identical UX across platforms

### The Tradeoff

Tauri/Rust has a steeper learning curve than JavaScript, which may reduce the contributor pool. However:

- The frontend is still React/TypeScript (familiar to most web devs)
- Rust's safety guarantees reduce bugs in critical video processing code
- The architecture isolates platform-specific code, making contributions focused

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                         OPEN SCREENSTUDIO                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                   FRONTEND (React + TypeScript)              │   │
│   │                                                              │   │
│   │   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │   │
│   │   │  Recording   │ │    Editor    │ │    Export    │        │   │
│   │   │    View      │ │     View     │ │     View     │        │   │
│   │   └──────────────┘ └──────────────┘ └──────────────┘        │   │
│   │                                                              │   │
│   │   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │   │
│   │   │   Timeline   │ │   Preview    │ │   Settings   │        │   │
│   │   │  Component   │ │   Player     │ │    Panel     │        │   │
│   │   └──────────────┘ └──────────────┘ └──────────────┘        │   │
│   │                                                              │   │
│   │   State: Zustand    │    Styling: Tailwind CSS              │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                   │                                 │
│                            Tauri IPC (Commands + Events)            │
│                                   │                                 │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                      BACKEND (Rust + Tauri)                  │   │
│   │                                                              │   │
│   │   ┌─────────────────────────────────────────────────────┐   │   │
│   │   │               Multi-Channel Recorder                 │   │   │
│   │   │                                                      │   │   │
│   │   │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │   │
│   │   │  │ Display │ │  Audio  │ │  Input  │ │ Webcam  │   │   │   │
│   │   │  │ Channel │ │ Channel │ │ Channel │ │ Channel │   │   │   │
│   │   │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │   │   │
│   │   │                      ↓                              │   │   │
│   │   │              HLS Segment Writer                      │   │   │
│   │   │              (fMP4, ~2s chunks)                      │   │   │
│   │   └─────────────────────────────────────────────────────┘   │   │
│   │                                                              │   │
│   │   ┌─────────────────────────────────────────────────────┐   │   │
│   │   │                   Core Modules                       │   │   │
│   │   │                                                      │   │   │
│   │   │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │   │
│   │   │  │ Project │ │ Export  │ │ Effects │ │ Preview │   │   │   │
│   │   │  │ Manager │ │ Engine  │ │ Pipeline│ │ Renderer│   │   │   │
│   │   │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │   │   │
│   │   │                                                      │   │   │
│   │   └─────────────────────────────────────────────────────┘   │   │
│   │                              │                               │   │
│   │   ┌─────────────────────────────────────────────────────┐   │   │
│   │   │              Platform Abstraction Layer              │   │   │
│   │   │                                                      │   │   │
│   │   │   Traits: ScreenCapture, AudioCapture, InputCapture │   │   │
│   │   └─────────────────────────────────────────────────────┘   │   │
│   │                              │                               │   │
│   └──────────────────────────────┼───────────────────────────────┘   │
│                                  │                                   │
│   ┌──────────────────────────────┴───────────────────────────────┐   │
│   │                     Platform Implementations                  │   │
│   │                                                               │   │
│   │   ┌─────────────────────┐     ┌─────────────────────┐        │   │
│   │   │       macOS         │     │       Windows       │        │   │
│   │   │                     │     │                     │        │   │
│   │   │  ScreenCaptureKit   │     │  Windows.Graphics   │        │   │
│   │   │  AVFoundation       │     │  .Capture           │        │   │
│   │   │  CoreAudio          │     │  WASAPI             │        │   │
│   │   │  CGEvent (Input)    │     │  Win32 API          │        │   │
│   │   └─────────────────────┘     └─────────────────────┘        │   │
│   │                                                               │   │
│   └───────────────────────────────────────────────────────────────┘   │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
Recording Flow (Multi-Channel):
──────────────────────────────
Display  ──► fMP4 Segments ──► channel-display-0-XXXX.m4s
System Audio ──► fMP4 Segments ──► channel-system-audio-0-XXXX.m4s
Microphone ──► fMP4 Segments ──► channel-microphone-0-XXXX.m4s
Webcam ──► fMP4 Segments ──► channel-webcam-0-XXXX.m4s
Mouse Position ──► JSON Buffer ──► mousemoves-0.json
Mouse Clicks ──► JSON Buffer ──► mouseclicks-0.json
Keystrokes ──► JSON Buffer ──► keystrokes-0.json
Cursor Images ──► PNG Files ──► cursors/*.png

Export Flow:
────────────
Project ──► Load Segments ──► Effect Pipeline ──► Zoom/Smooth ──► Compositor ──► Encoder ──► File
                                                       ▲
                                                Background/Style
```

---

## Project File Format

Open ScreenStudio uses a **directory bundle** format (`.osp`) for maximum transparency and debuggability.

### Bundle Structure

```
project.osp/
├── meta.json                   # Version info and metadata
├── project.json                # Main project configuration
├── markers.json                # User-defined markers
└── recording/                  # All captured data
    ├── metadata.json           # Recording configuration and session info
    │
    │   # Cursor Data
    ├── cursors.json            # Cursor type definitions
    ├── cursors/                # Cursor image assets
    │   ├── arrow.png
    │   ├── iBeam.png
    │   ├── pointingHand.png
    │   └── ...
    │
    │   # Input Tracking (per session)
    ├── mousemoves-0.json       # High-frequency mouse positions (~120Hz)
    ├── mouseclicks-0.json      # Click events
    ├── keystrokes-0.json       # Keyboard events
    │
    │   # Media Streams (HLS/fMP4 segments)
    ├── channel-display-0.m3u8
    ├── channel-display-0-0000.mp4    # Init segment
    ├── channel-display-0-0001.m4s    # ~2s video segments
    ├── channel-display-0-0002.m4s
    │   ...
    ├── channel-system-audio-0.m3u8
    ├── channel-system-audio-0-XXXX.m4s
    │
    ├── channel-microphone-0.m3u8
    ├── channel-microphone-0-XXXX.m4s
    │
    ├── channel-webcam-0.m3u8
    ├── channel-webcam-0-XXXX.m4s
    │
    └── recording.log           # Debug/diagnostic log
```

### meta.json

```json
{
  "version": "0.1.0",
  "format": "osp-v1",
  "createdAt": "2026-01-01T05:09:11.188Z",
  "updatedAt": "2026-01-01T06:42:59.929Z"
}
```

### project.json

```json
{
  "id": "unique-project-id",
  "name": "My Recording",
  "createdAt": "2026-01-01T05:09:11.159Z",
  "config": {
    "background": {
      "type": "gradient",
      "gradient": {
        "start": { "x": 0, "y": 0 },
        "end": { "x": 1, "y": 1 },
        "stops": [
          { "color": "#3F37C9", "at": 0 },
          { "color": "#8C87DF", "at": 1 }
        ]
      }
    },
    "padding": { "top": 0, "right": 0, "bottom": 0, "left": 0 },
    "shadow": {
      "intensity": 0.75,
      "angle": 90,
      "distance": 25,
      "blur": 20
    },
    "cursor": {
      "size": 1.5,
      "smoothing": {
        "enabled": true,
        "spring": { "stiffness": 470, "damping": 70, "mass": 3 }
      },
      "hideAfterMs": null
    },
    "camera": {
      "enabled": true,
      "position": "bottom-right",
      "size": 0.35,
      "roundness": 0.25,
      "mirror": false
    },
    "audio": {
      "systemVolume": 1,
      "microphoneVolume": 1,
      "enhanceMicrophone": true
    },
    "recordingRange": [0, 92937.68],
    "outputAspectRatio": { "x": 16, "y": 9 }
  },
  "scenes": [
    {
      "id": "scene-1",
      "name": "Default",
      "type": "recording",
      "sessionIndex": 0,
      "slices": [
        {
          "id": "slice-1",
          "sourceStartMs": 0,
          "sourceEndMs": 92937.68,
          "timeScale": 1,
          "volume": 1,
          "hideCursor": false,
          "disableCursorSmoothing": false
        }
      ],
      "zoomRanges": [
        {
          "id": "zoom-1",
          "startTime": 33007.03,
          "endTime": 35388.93,
          "zoom": 2,
          "type": "follow-cursor",
          "snapToEdges": 0.25,
          "instant": false
        }
      ],
      "layouts": [
        {
          "id": "layout-1",
          "startTime": 0,
          "endTime": 92937.68,
          "type": "screen-with-camera",
          "cameraSize": 0.35,
          "cameraPosition": { "x": 1, "y": 1 }
        }
      ]
    }
  ]
}
```

### recording/metadata.json

```json
{
  "version": "1.0.0",
  "state": "complete",
  "sessions": [
    {
      "durationMs": 92937.68,
      "processTimeStartMs": 1926.82,
      "processTimeEndMs": 94864.51,
      "unixStartMs": 1767244056884,
      "unixEndMs": 1767244149822
    }
  ],
  "channels": [
    {
      "id": "channel-display",
      "type": "display",
      "config": {
        "displayId": 1,
        "excludedWindowIds": []
      },
      "sessions": [
        {
          "outputFile": "channel-display-0.m3u8",
          "bounds": { "x": 0, "y": 0, "width": 1512, "height": 982 },
          "recordingScale": 0.5,
          "displayRefreshRate": 120,
          "durationMs": 92937.68
        }
      ]
    },
    {
      "id": "channel-system-audio",
      "type": "systemAudio",
      "sessions": [
        {
          "outputFile": "channel-system-audio-0.m3u8",
          "durationMs": 92937.68
        }
      ]
    },
    {
      "id": "channel-microphone",
      "type": "microphone",
      "config": { "deviceId": "..." },
      "sessions": [
        {
          "outputFile": "channel-microphone-0.m3u8",
          "durationMs": 92937.68
        }
      ]
    },
    {
      "id": "channel-webcam",
      "type": "webcam",
      "config": { "deviceId": "..." },
      "sessions": [
        {
          "outputFile": "channel-webcam-0.m3u8",
          "videoSize": { "width": 1920, "height": 1080 },
          "frameRate": 30,
          "durationMs": 92937.69
        }
      ]
    },
    {
      "id": "channel-input",
      "type": "input",
      "config": { "captureKeystrokes": true },
      "sessions": [
        {
          "mouseMovesFile": "mousemoves-0.json",
          "mouseClicksFile": "mouseclicks-0.json",
          "keystrokesFile": "keystrokes-0.json",
          "durationMs": 92937.68
        }
      ]
    },
    {
      "id": "channel-cursor",
      "type": "cursor",
      "cursorsInfoFile": "cursors.json",
      "cursorImagesFolder": "cursors"
    }
  ]
}
```

---

## Recording System

### Multi-Channel Architecture

Recording captures multiple independent streams simultaneously:

| Channel | Content | Format | Purpose |
|---------|---------|--------|---------|
| display | Screen video | fMP4/HLS | Main screen content |
| system-audio | System audio | fMP4/HLS | App sounds, music |
| microphone | Mic audio | fMP4/HLS | Voice narration |
| webcam | Camera video | fMP4/HLS | Presenter overlay |
| input | Mouse/keyboard | JSON | Cursor smoothing, zoom triggers |
| cursor | Cursor images | PNG | Cursor rendering |

### HLS/fMP4 Segmented Recording

Benefits of segmented recording:
- **Crash recovery**: Only lose the last segment on crash
- **Streaming playback**: Preview while recording
- **Efficient seeking**: Jump to any segment without full decode
- **Memory efficient**: No need to buffer entire recording

Segment configuration:
- Target duration: **2 seconds**
- Format: **fMP4** (fragmented MP4)
- Playlist: **HLS m3u8** for segment indexing

### Session Management

Recordings support multiple sessions (pause/resume):
- Each pause creates a new session
- Sessions have independent media files
- Timeline stitches sessions together seamlessly

---

## Input Tracking System

### Mouse Movement Tracking

Captured at display refresh rate (~120Hz on modern displays):

```json
{
  "type": "mouseMoved",
  "x": 272.175,
  "y": 864.582,
  "cursorId": "arrow",
  "activeModifiers": [],
  "processTimeMs": 7915.316,
  "unixTimeMs": 1767244062872
}
```

Fields:
- `x`, `y`: Screen coordinates (sub-pixel precision)
- `cursorId`: Current cursor type
- `activeModifiers`: Keys held (shift, cmd, etc.)
- `processTimeMs`: Recording-relative timestamp
- `unixTimeMs`: Absolute timestamp for sync

### Mouse Click Tracking

```json
{
  "type": "mouseDown",
  "button": "left",
  "x": 374.152,
  "y": 55.648,
  "cursorId": "arrow",
  "activeModifiers": [],
  "processTimeMs": 26117.683,
  "unixTimeMs": 1767244081074
}
```

Click types: `mouseDown`, `mouseUp`
Buttons: `left`, `right`, `middle`

### Keystroke Tracking

```json
{
  "type": "keyDown",
  "character": "h",
  "activeModifiers": [],
  "isARepeat": false,
  "processTimeMs": 55339.872,
  "unixTimeMs": 1767244110297
}
```

Used for:
- Keyboard shortcut overlay
- Transcript generation
- Zoom triggers on typing

### Cursor Image Capture

```json
{
  "id": "arrow",
  "hotSpot": { "x": 4, "y": 4 },
  "standardSize": { "width": 17, "height": 23 },
  "systemCursor": true
}
```

- Capture all cursor variants encountered
- Store as PNG with transparency
- Track hotspot for accurate positioning

---

## Editing Model

### Scene-Based Organization

Projects contain one or more scenes:
- **Recording scene**: Based on captured footage
- **Title scene**: Static text/image (future)
- **Transition scene**: Between scenes (future)

### Timeline Slices

Slices represent segments of source media with individual settings:

```json
{
  "id": "slice-1",
  "sourceStartMs": 0,
  "sourceEndMs": 10000,
  "timeScale": 1,      // 0.5 = slow-mo, 2 = fast-forward
  "volume": 1,
  "hideCursor": false,
  "disableCursorSmoothing": false
}
```

### Zoom Ranges

Define automatic zoom regions:

```json
{
  "id": "zoom-1",
  "startTime": 33007.03,
  "endTime": 35388.93,
  "zoom": 2,
  "type": "follow-cursor",      // or "manual", "follow-clicks"
  "targetPoint": { "x": 0.5, "y": 0.5 },  // for manual
  "snapToEdges": 0.25,
  "instant": false
}
```

Zoom types:
- `follow-cursor`: Track cursor position
- `follow-clicks`: Center on click locations
- `manual`: Fixed position

### Layout Keyframes

Define camera/screen arrangement over time:

```json
{
  "id": "layout-1",
  "startTime": 0,
  "endTime": 30000,
  "type": "screen-with-camera",
  "cameraSize": 0.35,
  "cameraPosition": { "x": 1, "y": 1 }  // bottom-right
}
```

Layout types:
- `screen-only`: Full screen, no camera
- `camera-only`: Full camera, no screen
- `screen-with-camera`: Screen with camera overlay
- `side-by-side`: Split view

---

## Effects & Animation

### Spring Physics

All smooth movements use spring physics for natural motion:

```json
{
  "cursorMovementSpring": {
    "stiffness": 470,
    "damping": 70,
    "mass": 3
  },
  "screenMovementSpring": {
    "stiffness": 200,
    "damping": 40,
    "mass": 2.25
  },
  "zoomSpring": {
    "stiffness": 700,
    "damping": 30,
    "mass": 1
  }
}
```

### Cursor Smoothing Algorithm

1. Read raw mouse positions from `mousemoves-0.json`
2. Apply spring physics simulation
3. Interpolate between frames at output framerate
4. Handle edge cases (teleporting cursor, edge of screen)

### Automatic Zoom Algorithm

1. Detect click events from `mouseclicks-0.json`
2. Group nearby clicks within time window
3. Calculate zoom region to encompass click group
4. Apply spring physics for smooth zoom transition
5. Snap to screen edges if close enough

---

## Technology Choices

### Backend (Rust)

| Component | Technology | Purpose |
|-----------|------------|---------|
| **Framework** | Tauri 2.0 | App framework, IPC, windowing |
| **Async Runtime** | Tokio | Async I/O, timers |
| **Video Encoding** | FFmpeg (ffmpeg-next) | Encode to MP4, GIF, fMP4 segments |
| **HLS** | Custom | M3U8 playlist generation |
| **Serialization** | Serde | JSON for project files |
| **Error Handling** | thiserror, anyhow | Ergonomic error types |

### Frontend (TypeScript)

| Component | Technology | Purpose |
|-----------|------------|---------|
| **Framework** | React 18 | UI components |
| **Language** | TypeScript | Type safety |
| **Build Tool** | Vite | Fast HMR, optimized builds |
| **Styling** | Tailwind CSS | Utility-first CSS |
| **State** | Zustand | Lightweight state management |
| **Video Playback** | hls.js | HLS segment playback |
| **Icons** | Lucide React | Consistent iconography |

### Platform Requirements

| Platform | Minimum Version | Reason |
|----------|-----------------|--------|
| **macOS** | 13.0 (Ventura) | ScreenCaptureKit improvements |
| **Windows** | 11 | Windows.Graphics.Capture stability |

---

## Platform APIs

### macOS (13.0+)

| Feature | API | Notes |
|---------|-----|-------|
| **Screen Capture** | ScreenCaptureKit | Primary API, requires permission |
| **Window List** | ScreenCaptureKit | SCShareableContent |
| **System Audio** | ScreenCaptureKit | SCStreamConfiguration |
| **Microphone** | AVFoundation | AVAudioEngine |
| **Webcam** | AVFoundation | AVCaptureSession |
| **Cursor Position** | CGEvent | High-frequency polling |
| **Cursor Image** | CoreGraphics | CGDisplayCopyCurrentCursor |
| **Keyboard Events** | CGEvent | Key capture with modifiers |
| **Permissions** | AVFoundation | Screen recording permission |

### Windows (11+)

| Feature | API | Notes |
|---------|-----|-------|
| **Screen Capture** | Windows.Graphics.Capture | GraphicsCaptureItem |
| **Window List** | Win32 | EnumWindows |
| **System Audio** | WASAPI | Loopback capture |
| **Microphone** | WASAPI | Standard capture |
| **Webcam** | Windows.Media.Capture | MediaCapture |
| **Cursor Position** | Win32 | GetCursorPos |
| **Cursor Image** | Win32 | GetCursorInfo |
| **Keyboard Events** | Win32 | SetWindowsHookEx |
| **Permissions** | Windows Settings | Prompt user if needed |

---

## Project Structure

```
open-screenstudio/
├── .github/
│   ├── workflows/
│   │   ├── ci.yml
│   │   ├── release.yml
│   │   └── pr-check.yml
│   └── ISSUE_TEMPLATE/
│
├── docs/
│   ├── VISION.md
│   ├── FEATURES.md
│   ├── ROADMAP.md
│   ├── TECHNICAL_PLAN.md
│   └── ARCHITECTURE.md
│
├── src/                           # React frontend
│   ├── components/
│   │   ├── ui/
│   │   ├── recording/
│   │   ├── editor/
│   │   └── export/
│   ├── hooks/
│   ├── stores/
│   ├── lib/
│   ├── types/
│   ├── App.tsx
│   ├── main.tsx
│   └── index.css
│
├── src-tauri/                     # Rust backend
│   ├── src/
│   │   ├── main.rs
│   │   ├── lib.rs
│   │   │
│   │   ├── commands/              # Tauri IPC handlers
│   │   │   ├── mod.rs
│   │   │   ├── recording.rs
│   │   │   ├── project.rs
│   │   │   ├── export.rs
│   │   │   └── system.rs
│   │   │
│   │   ├── recorder/              # Multi-channel recording
│   │   │   ├── mod.rs
│   │   │   ├── coordinator.rs     # Orchestrates all channels
│   │   │   ├── channel.rs         # Channel trait
│   │   │   ├── display.rs         # Screen capture channel
│   │   │   ├── audio.rs           # Audio capture channel
│   │   │   ├── webcam.rs          # Camera capture channel
│   │   │   ├── input.rs           # Mouse/keyboard channel
│   │   │   ├── cursor.rs          # Cursor image capture
│   │   │   └── segment_writer.rs  # HLS/fMP4 segment writing
│   │   │
│   │   ├── capture/               # Platform capture implementations
│   │   │   ├── mod.rs
│   │   │   ├── traits.rs
│   │   │   ├── macos/
│   │   │   │   ├── mod.rs
│   │   │   │   ├── screen.rs      # ScreenCaptureKit
│   │   │   │   ├── audio.rs       # CoreAudio
│   │   │   │   ├── webcam.rs      # AVFoundation
│   │   │   │   ├── input.rs       # CGEvent
│   │   │   │   └── cursor.rs      # CoreGraphics
│   │   │   └── windows/
│   │   │       ├── mod.rs
│   │   │       ├── screen.rs
│   │   │       ├── audio.rs
│   │   │       ├── webcam.rs
│   │   │       ├── input.rs
│   │   │       └── cursor.rs
│   │   │
│   │   ├── processing/            # Video/audio processing
│   │   │   ├── mod.rs
│   │   │   ├── spring.rs          # Spring physics simulation
│   │   │   ├── cursor_smooth.rs   # Cursor smoothing
│   │   │   ├── zoom.rs            # Automatic zoom algorithm
│   │   │   ├── effects.rs         # Visual effects
│   │   │   └── compositor.rs      # Layer composition
│   │   │
│   │   ├── export/                # Video encoding
│   │   │   ├── mod.rs
│   │   │   ├── encoder.rs         # FFmpeg encoding
│   │   │   ├── formats.rs         # MP4, GIF, WebM
│   │   │   └── presets.rs         # Export presets
│   │   │
│   │   ├── project/               # Project management
│   │   │   ├── mod.rs
│   │   │   ├── bundle.rs          # .osp bundle read/write
│   │   │   ├── schema.rs          # JSON schemas
│   │   │   └── migration.rs       # Version migration
│   │   │
│   │   └── utils/
│   │       ├── mod.rs
│   │       ├── error.rs
│   │       └── logging.rs
│   │
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   └── build.rs
│
├── package.json
├── tsconfig.json
├── tailwind.config.js
├── vite.config.ts
├── README.md
├── CONTRIBUTING.md
└── LICENSE
```

---

## Key Dependencies

### Rust Crates

```toml
[dependencies]
# Tauri
tauri = { version = "2", features = ["macos-private-api"] }
tauri-plugin-shell = "2"
tauri-plugin-dialog = "2"
tauri-plugin-fs = "2"

# Async
tokio = { version = "1", features = ["full"] }

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Video/Audio Processing
ffmpeg-next = "7"

# Image Processing
image = "0.25"

# Error Handling
thiserror = "1"
anyhow = "1"

# Logging
tracing = "0.1"
tracing-subscriber = "0.3"

# Platform: macOS
[target.'cfg(target_os = "macos")'.dependencies]
objc2 = "0.5"
block2 = "0.5"
core-foundation = "0.9"
core-graphics = "0.23"

# Platform: Windows
[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = [
    "Graphics_Capture",
    "Win32_System_WinRT",
    "Win32_UI_WindowsAndMessaging",
    "Media_Audio",
    "Media_Capture",
]}
```

### Node Packages

```json
{
  "dependencies": {
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "zustand": "^4.5.0",
    "hls.js": "^1.5.0",
    "lucide-react": "^0.400.0",
    "@tauri-apps/api": "^2.0.0",
    "@tauri-apps/plugin-dialog": "^2.0.0",
    "@tauri-apps/plugin-fs": "^2.0.0"
  },
  "devDependencies": {
    "typescript": "^5.5.0",
    "vite": "^5.4.0",
    "@vitejs/plugin-react": "^4.3.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "eslint": "^9.0.0",
    "prettier": "^3.3.0"
  }
}
```

---

## Implementation Phases

### Phase 0: Project Setup (Week 1)

**Goal:** Working Tauri app with basic UI

- [ ] Initialize Tauri 2.0 project
- [ ] Configure React + TypeScript + Vite
- [ ] Set up Tailwind CSS
- [ ] Create basic app layout (3 views: Record, Edit, Export)
- [ ] Set up GitHub Actions CI/CD
- [ ] Define TypeScript types for project format
- [ ] Implement project bundle read/write

**Deliverable:** App opens, can create/save empty projects

### Phase 1: Multi-Channel Recording Infrastructure (Weeks 2-3)

**Goal:** Recording coordinator with segment writing

- [ ] Implement channel trait and coordinator
- [ ] Implement HLS/fMP4 segment writer
- [ ] macOS: ScreenCaptureKit screen capture channel
- [ ] Windows: Windows.Graphics.Capture channel
- [ ] Generate m3u8 playlists
- [ ] Simple UI: source picker, record button

**Deliverable:** Can record screen to segmented fMP4

### Phase 2: Audio Channels (Week 4)

**Goal:** Add audio recording channels

- [ ] macOS: System audio channel (ScreenCaptureKit)
- [ ] macOS: Microphone channel (AVFoundation)
- [ ] Windows: WASAPI system audio loopback
- [ ] Windows: WASAPI microphone
- [ ] Audio/video timestamp synchronization
- [ ] Audio level meters in UI

**Deliverable:** Record screen with synced audio

### Phase 3: Input Tracking Channel (Week 5)

**Goal:** High-frequency input capture

- [ ] macOS: CGEvent mouse position tracking
- [ ] macOS: CGEvent keyboard tracking
- [ ] Windows: Win32 input tracking
- [ ] JSON buffer and periodic flush
- [ ] Capture cursor images to PNG
- [ ] Store cursor metadata

**Deliverable:** Full input tracking during recording

### Phase 4: Webcam Channel (Week 6)

**Goal:** Camera recording

- [ ] macOS: AVFoundation webcam capture
- [ ] Windows: MediaCapture webcam
- [ ] Camera preview in UI
- [ ] Camera device selection

**Deliverable:** Record with webcam overlay

### Phase 5: Cursor Smoothing (Week 7)

**Goal:** Smooth cursor movement in playback

- [ ] Implement spring physics simulation
- [ ] Read mouse moves from JSON
- [ ] Interpolate positions at output framerate
- [ ] Handle teleporting cursor
- [ ] Preview smoothing in editor
- [ ] Configurable smoothing intensity

**Deliverable:** Smooth cursor in preview/export

### Phase 6: Automatic Zoom (Week 8)

**Goal:** Click-based automatic zoom

- [ ] Click detection from JSON data
- [ ] Click grouping algorithm
- [ ] Zoom region calculation
- [ ] Spring physics for zoom transitions
- [ ] Snap to edges
- [ ] Zoom range UI in timeline

**Deliverable:** Automatic zoom working

### Phase 7: Basic Editor (Weeks 9-10)

**Goal:** Timeline-based editing

- [ ] HLS.js player for segment playback
- [ ] Timeline component with thumbnails
- [ ] Playhead and seeking
- [ ] Trim start/end (adjust recording range)
- [ ] Cut and remove sections (slices)
- [ ] Undo/redo system

**Deliverable:** Basic non-destructive editing

### Phase 8: Layout System (Week 11)

**Goal:** Camera/screen arrangement

- [ ] Layout keyframe data structure
- [ ] Layout transition animations
- [ ] Camera position/size controls
- [ ] Layout presets (full screen, picture-in-picture, etc.)
- [ ] Real-time preview

**Deliverable:** Configurable camera layouts

### Phase 9: Styling System (Week 12)

**Goal:** Backgrounds and visual polish

- [ ] Background colors and gradients
- [ ] Padding/spacing controls
- [ ] Corner radius
- [ ] Drop shadow
- [ ] Real-time preview

**Deliverable:** Styled output

### Phase 10: Export System (Week 13)

**Goal:** Production-ready export

- [ ] Read all segments and stitch
- [ ] Apply effects pipeline (zoom, smooth, composite)
- [ ] MP4 export with quality options
- [ ] GIF export with optimization
- [ ] Progress indication
- [ ] Hardware acceleration

**Deliverable:** Export polished videos

### Phase 11: Polish & MVP Release (Week 14)

**Goal:** Ship it!

- [ ] Bug fixes and edge cases
- [ ] Performance optimization
- [ ] UI polish and animations
- [ ] User documentation
- [ ] Release builds for macOS and Windows

**Deliverable:** MVP release v0.1.0

---

## Open Questions

### 1. Segment Duration

Current plan: 2 seconds
- Shorter = more files, more overhead, finer crash recovery
- Longer = fewer files, less overhead, coarser recovery

**Decision needed:** Stick with 2s or adjust?

### 2. Input Capture Rate

Current plan: Display refresh rate (~120Hz)
- Higher = smoother cursor, larger files
- Lower = smaller files, potentially jerky cursor

**Decision needed:** Fixed rate or adaptive?

### 3. Cursor Image Capture

Options:
- Capture all unique cursors encountered
- Only capture on cursor change
- Pre-bundle common system cursors

**Decision needed:** Balance file size vs accuracy

---

## Getting Started (Development)

### Prerequisites

**All Platforms:**
- Node.js 20+
- Rust 1.75+
- Git
- FFmpeg

**macOS:**
- Xcode Command Line Tools
- macOS 13.0+ (Ventura)

**Windows:**
- Visual Studio 2022 Build Tools
- Windows 11 SDK
- WebView2 Runtime

### Setup

```bash
# Clone the repository
git clone https://github.com/crafter-station/open-screenstudio.git
cd open-screenstudio

# Install Node dependencies
npm install

# Install Rust dependencies
cd src-tauri && cargo fetch && cd ..

# Run in development mode
npm run tauri dev
```

### Development Commands

```bash
npm run tauri dev      # Development with hot reload
npm run tauri build    # Production build
npm run dev            # Frontend only
npm run lint           # Lint code
npm run format         # Format code
npm run test           # Frontend tests
cd src-tauri && cargo test  # Backend tests
```

---

## Feedback Welcome!

This technical plan is open for discussion. We want to hear from you:

- **Disagree with a decision?** Open an issue explaining your concerns
- **Have experience with these technologies?** Share your insights
- **See a potential problem?** Let us know before we hit it

**Start a discussion:** [GitHub Discussions](https://github.com/crafter-station/open-screenstudio/discussions)
```

---

## Verification

After applying changes:
1. Read the updated `docs/TECHNICAL_PLAN.md` to verify all sections are present
2. Check that JSON schemas are correctly formatted
3. Verify the project structure reflects the new architecture
4. Ensure implementation phases align with multi-channel recording approach
