# Open ScreenStudio - Full MVP Implementation Plan

---

## CURRENT ISSUE: Cursor Position Still Misaligned in Editor

### Problem Statement

Despite previous Y-axis fixes, the cursor overlay is still NOT aligned with the actual cursor in the video. The overlay cursor appears in a completely different position than where the cursor is visible in the recorded video content.

### Root Cause Analysis (Deep Dive)

After extensive tracing of the entire pipeline, **multiple bugs** were identified:

#### Bug #1: Cursor Image Dimensions Mismatch (CRITICAL)

**Location:** `src-tauri/src/capture/macos/input.rs:245-248`

```rust
Some(CursorInfo {
    hotspot_x: hotspot.x,           // LOGICAL POINTS (e.g., 4)
    hotspot_y: hotspot.y,           // LOGICAL POINTS (e.g., 4)
    width: size.width as u32,       // LOGICAL POINTS (e.g., 32)
    height: size.height as u32,     // LOGICAL POINTS (e.g., 32)
})
```

- `NSImage::size()` returns dimensions in **logical points** (e.g., 32x32)
- `NSCursor::hotSpot()` returns position in **logical points** (e.g., 4, 4)
- But the saved PNG from `NSBitmapImageRep` is at **pixel resolution** (e.g., 64x64 on Retina)

**Result:** The playback code thinks the cursor is 32x32, but the actual image is 64x64. Hotspot calculations are off by 2x on Retina displays.

#### Bug #2: Cursor Scaling Logic in CursorOverlay.tsx

**Location:** `src/components/editor/CursorOverlay.tsx:107-111`

```typescript
const cursorScale = scale * cursorSize;
const hotspotOffsetX = cursorInfo ? cursorInfo.hotspotX * cursorScale : 0;
const hotspotOffsetY = cursorInfo ? cursorInfo.hotspotY * cursorScale : 0;
```

Then applied as:

```typescript
style={{
  left: smoothedX - hotspotOffsetX,
  top: smoothedY - hotspotOffsetY,
  transform: `scale(${cursorScale})`,
  transformOrigin: "top left",
}}
```

**Problem:**

- `cursorInfo.hotspotX/Y` are in logical points (e.g., 4)
- `cursorScale` = video-to-container scale \* user multiplier
- But the cursor IMAGE loads at its native pixel size (64x64)
- The `transform: scale()` scales the pixel-sized image
- The hotspot offset is calculated wrong because it mixes coordinate systems

#### Bug #3: The Cursor PNG is Already at Video Resolution

The cursor PNG is saved at the same DPI as the video (Retina pixel resolution). When the video is scaled down to fit the container (e.g., from 2880x1800 to 960x600), the cursor should scale by the same factor.

But the current code applies:

1. `scale` from video-to-container (correct)
2. Uses `cursorInfo.width` which is in logical points, not pixels (incorrect)
3. Hotspot offset calculated from logical points (incorrect)

### Fix Plan

#### Step 1: Store PIXEL Dimensions for Cursor in Rust

**File:** `src-tauri/src/capture/macos/input.rs`

Use `NSBitmapImageRep::pixelsWide()` and `pixelsHigh()` instead of `NSImage::size()`:

```rust
fn capture_cursor_png(...) -> Option<CursorInfo> {
    unsafe {
        let hotspot = cursor.hotSpot();
        let image: Retained<NSImage> = cursor.image();
        let logical_size = image.size();  // Logical points (e.g., 32x32)

        // ... save PNG ...

        let bitmap = NSBitmapImageRep::imageRepWithData(&tiff_data)?;

        // Get actual PIXEL dimensions of the saved PNG
        let pixel_width = bitmap.pixelsWide() as u32;
        let pixel_height = bitmap.pixelsHigh() as u32;

        // Convert hotspot from logical points to pixel coordinates
        let scale_x = pixel_width as f64 / logical_size.width;
        let scale_y = pixel_height as f64 / logical_size.height;

        Some(CursorInfo {
            id: cursor_id.to_string(),
            image_path: image_path.to_string_lossy().to_string(),
            hotspot_x: hotspot.x * scale_x,  // Now in PIXELS
            hotspot_y: hotspot.y * scale_y,  // Now in PIXELS
            width: pixel_width,               // Now in PIXELS
            height: pixel_height,             // Now in PIXELS
        })
    }
}
```

#### Step 2: Simplify Cursor Scaling in TypeScript

**File:** `src/components/editor/CursorOverlay.tsx`

Since cursor dimensions and hotspot are now in pixels (matching video resolution), the scaling becomes straightforward:

```typescript
// The cursor image is at video pixel resolution.
// We scale it by the same factor as the video (scale) plus user preference (cursorSize).
const cursorScale = scale * cursorSize;

// Hotspot is now in pixel coordinates, scale same as cursor image
const hotspotOffsetX = cursorInfo ? cursorInfo.hotspotX * cursorScale : 0;
const hotspotOffsetY = cursorInfo ? cursorInfo.hotspotY * cursorScale : 0;

// This is now correct because all values are in consistent pixel coordinates
```

### Files to Modify

| File                                   | Changes                                                                        |
| -------------------------------------- | ------------------------------------------------------------------------------ |
| `src-tauri/src/capture/macos/input.rs` | Use `pixelsWide()/pixelsHigh()` for cursor dimensions, scale hotspot to pixels |

### Verification

1. `bun run tauri:dev`
2. Make a new recording (important: old recordings have wrong cursor data)
3. Move cursor around the screen
4. Stop recording, click "Edit"
5. Verify cursor overlay matches cursor in video at ALL positions:
   - Top-left corner
   - Center
   - Bottom-right corner
   - During movement

---

## PREVIOUS ISSUES (Context)

---

## PREVIOUS ISSUE: Toolbar Border + Dropdown Cut Off (RESOLVED)

### Problems Identified

1. **Border still visible around toolbar pill** - Despite multiple CSS fixes, a visible border/outline persists around the toolbar.

2. **Display dropdown cut off on left edge** - The Display dropdown appears cut off, needs padding on the container.

### Deep Analysis - Border Issue

After examining the built CSS, the root cause is **Tailwind's CSS Preflight**:

```css
*,
:before,
:after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: #e5e7eb;
}
```

This sets `border-style: solid` and `border-color: #e5e7eb` (light gray) on ALL elements. Even with `border-width: 0`, some rendering engines still show a hairline when combined with:

- `border-radius`
- `backdrop-filter`
- Transparent backgrounds

**Solution**: Override at the Tailwind preflight level by modifying `tailwind.config.js` to disable preflight borders for toolbar, OR add explicit resets in the component itself.

### Fix Plan

#### Step 1: Disable Tailwind Preflight Border Styles for Toolbar

In `src/index.css`, add a rule that completely resets border properties AFTER Tailwind loads:

```css
/* Reset Tailwind preflight borders for toolbar */
.toolbar-container,
.toolbar-container *,
.toolbar-container *::before,
.toolbar-container *::after {
  border: 0 solid transparent !important;
  border-color: transparent !important;
  outline: none !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); /* Only for .toolbar-content */
}
```

And specifically for `.toolbar-content`:

```css
.toolbar-content {
  border: none !important;
  border-color: transparent !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}
```

#### Step 2: Add Horizontal Padding to Container

Change `.toolbar-container` padding from `4px` to `16px 20px` to prevent dropdown cutoff:

```css
.toolbar-container {
  padding: 4px 20px;
}
```

### Files to Modify

1. `src/index.css`:
   - Add `border-color: transparent !important` to toolbar elements
   - Increase horizontal padding on `.toolbar-container`

### Verification

1. Run `bun run tauri:dev`
2. Toolbar pill should have NO visible border/outline
3. Click Display dropdown - should not be cut off on the left
4. All dropdowns should be fully visible

---

## App Redesign - Screen Studio-Style Flow

**Goal:** Redesign the app to match Screen Studio's minimal, floating-window workflow instead of a full sidebar app.

### Reference Analysis (from provided images)

**Image 1 - Recording Toolbar:**

- Small, pill-shaped floating window (~600x80px)
- Horizontal layout with source buttons: Display, Window, Area, Device
- Camera toggle with "No camera" label
- Microphone toggle with "No microphone" label
- System audio toggle: "Record system audio"
- Settings gear icon on right
- Close (X) button on left
- Dark semi-transparent background with rounded corners

**Image 2 - Post-Recording Popup:**

- Small floating window over the screen recording preview
- Four action buttons: Save..., Copy, Share, Edit
- Shows export info at bottom: "MP4 • 2160p • 60fps • Social Media"
- "Will export" label
- Audio and settings icons

**Images 3-6 - Full Editor:**

- Large window with video preview centered
- Wallpaper/background behind video (gradient options)
- Right sidebar with context-aware properties:
  - Cursor: size slider, style options (4 cursor styles), hide options, click effect
  - Animation: Screen animation style (Focused/Smooth), cursor animation (Smooth/Medium/Rapid/None), motion blur
  - Audio: System audio mute, background audio categories (Lo-Fi, Commercial, Electronic)
- Bottom timeline with waveform visualization
- Playback controls centered below preview
- Zoom/scrub controls in timeline area

---

### Visual Style Reference

**1. Core Aesthetic**

- **Style:** Dark, minimal, professional
- **Philosophy:** Focus on content with unobtrusive controls
- **Influences:** macOS native design, floating toolbar paradigm

**2. Color Palette**
| Color | Hex | Usage |
|-------|-----|-------|
| Background (dark) | `#1a1a1a` | Main app background |
| Surface | `#2d2d2d` | Panels, toolbars |
| Surface elevated | `#3d3d3d` | Hover states, selected items |
| Border | `#404040` | Subtle dividers |
| Text primary | `#ffffff` | Main text |
| Text secondary | `#9ca3af` | Labels, hints |
| Accent purple | `#8b5cf6` | Selected states, active controls |
| Timeline track | `#d97706` | Audio waveform |

**3. Typography**

- System font (SF Pro on macOS)
- 13px base size for UI labels
- 11px for secondary labels
- Medium weight for buttons
- Regular for body text

**4. Key Design Elements**

- Rounded corners (8-12px radius)
- Subtle shadows on floating windows
- Icon-heavy interface (minimal text)
- Segmented controls for options
- Slider controls with value labels
- Toggle switches for on/off states

---

### New App Flow

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  1. APP LAUNCH                                              │
│     └─> Show Recording Toolbar (small floating window)      │
│                                                             │
│  2. RECORDING                                               │
│     ├─> User configures sources (display/window/area)       │
│     ├─> User toggles camera/mic/system audio                │
│     └─> User clicks to start recording                      │
│                                                             │
│  3. RECORDING IN PROGRESS                                   │
│     └─> Toolbar minimizes or shows recording indicator      │
│                                                             │
│  4. RECORDING STOPPED                                       │
│     └─> Show Post-Recording Popup with options:             │
│         ├─> Save... (quick export)                          │
│         ├─> Copy (to clipboard)                             │
│         ├─> Share                                           │
│         └─> Edit (opens full editor)                        │
│                                                             │
│  5. FULL EDITOR (if Edit clicked)                           │
│     ├─> Large window with video preview                     │
│     ├─> Timeline at bottom                                  │
│     ├─> Properties panel on right                           │
│     └─> Export when ready                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### Implementation Plan

#### Phase A: Window Management & Recording Toolbar

**A1. Update Tauri Window Configuration**

File: `src-tauri/tauri.conf.json`

```json
{
  "windows": [
    {
      "label": "recording-toolbar",
      "title": "Open ScreenStudio",
      "width": 650,
      "height": 80,
      "minWidth": 600,
      "minHeight": 80,
      "resizable": false,
      "decorations": false,
      "transparent": true,
      "alwaysOnTop": true,
      "center": true
    }
  ]
}
```

**A2. Create Recording Toolbar Component**

File: `src/components/recording/RecordingToolbar.tsx`

- Pill-shaped container with drag handle
- Source selection buttons (Display, Window, Area, Device)
- Camera dropdown/toggle
- Microphone dropdown/toggle
- System audio toggle
- Settings button
- Close button
- Start recording button (appears when ready)

**A3. Update App.tsx for Multi-Window Support**

- Detect current window context
- Render appropriate view based on window label
- Handle window transitions (toolbar -> editor)

#### Phase B: Post-Recording Popup

**B1. Create Post-Recording Component**

File: `src/components/recording/PostRecordingPopup.tsx`

- Small floating window design
- Thumbnail preview of recording
- Action buttons: Save, Copy, Share, Edit
- Export format info display

**B2. Add Tauri Commands for Window Management**

File: `src-tauri/src/commands/window.rs`

- `open_editor_window` - Opens full editor for a recording
- `close_recording_toolbar` - Closes the toolbar
- `show_post_recording` - Shows the popup after recording

#### Phase C: Editor Redesign

**C1. Redesign Editor Layout**

File: `src/components/editor/EditorView.tsx`

New layout structure:

```
┌──────────────────────────────────────────────────────────────────┐
│ [Header: project name, presets dropdown, export button]          │
├─────────────────────────────────────────────────┬────────────────┤
│                                                 │  Properties    │
│              Video Preview                      │  Panel         │
│              (with background)                  │  (context-     │
│                                                 │   aware)       │
├─────────────────────────────────────────────────┴────────────────┤
│ [Playback controls: play, skip, speed]                           │
├──────────────────────────────────────────────────────────────────┤
│                        Timeline                                  │
│ [Video track with thumbnails]                                    │
│ [Audio waveform track]                                           │
└──────────────────────────────────────────────────────────────────┘
```

**C2. Create Properties Panel Tabs**

File: `src/components/editor/PropertiesPanel.tsx`

Sections (icons on side):

- Screen/Video settings
- Cursor settings
- Camera settings (if webcam recorded)
- Audio settings
- Background settings
- Zoom/Animation settings

**C3. Update Cursor Settings UI**

Based on reference images:

- Cursor size slider with "Reset" button
- Cursor style picker (4 options: default, pointer, circle, inverted)
- "Always use pointer cursor" toggle
- "Hide cursor if not moving" toggle
- "Loop cursor position" toggle
- "Hide cursor" toggle
- Click effect dropdown
- Click sound dropdown

#### Phase D: Timeline Enhancement

**D1. Create Timeline Component**

File: `src/components/editor/Timeline.tsx`

Features:

- Visible timeline toggle dropdown
- Playback controls (previous, play/pause, next)
- Cut tool
- Audio waveform toggle
- Zoom controls
- Speed indicator
- Time ruler with markers
- Video track with clip visualization
- Audio track with waveform
- Playhead with drag

---

### Files to Create

| File                                              | Description                   |
| ------------------------------------------------- | ----------------------------- |
| `src/components/recording/RecordingToolbar.tsx`   | New compact recording UI      |
| `src/components/recording/PostRecordingPopup.tsx` | Post-recording actions        |
| `src/components/editor/PropertiesPanel.tsx`       | Tabbed properties sidebar     |
| `src/components/editor/Timeline.tsx`              | Enhanced timeline component   |
| `src/components/editor/VideoPreview.tsx`          | Video preview with background |
| `src-tauri/src/commands/window.rs`                | Window management commands    |

### Files to Modify

| File                                   | Changes                                   |
| -------------------------------------- | ----------------------------------------- |
| `src-tauri/tauri.conf.json`            | Window configuration for floating toolbar |
| `src/App.tsx`                          | Multi-window detection, new routing       |
| `src/components/editor/EditorView.tsx` | New layout structure                      |
| `src/stores/projectStore.ts`           | Add recording state, window state         |
| `src-tauri/src/lib.rs`                 | Register new window commands              |

---

### Step-by-Step Implementation Order

Each step will be committed separately for progress tracking.

#### Step 1: Tauri Multi-Window Setup

- Update `tauri.conf.json` with two window configs (toolbar + editor)
- Add window management commands to Rust backend
- Test: App can open/close multiple windows

#### Step 2: Recording Toolbar UI

- Create `RecordingToolbar.tsx` component
- Implement source selection (Display, Window, Area, Device)
- Implement camera/mic/system audio toggles
- Style with dark theme, rounded pill shape
- Test: Toolbar renders with all controls

#### Step 3: App Entry Point Routing

- Update `App.tsx` to detect window label
- Render RecordingToolbar for toolbar window
- Render Editor for editor window
- Test: Different windows show different UIs

#### Step 4: Recording Integration

- Connect toolbar to existing recording commands
- Add recording state indicators
- Implement start/stop flow
- Test: Can start and stop recording from toolbar

#### Step 5: Post-Recording Popup

- Create `PostRecordingPopup.tsx` component
- Show after recording stops
- Implement Save, Copy, Share, Edit buttons
- Test: Popup appears after recording

#### Step 6: Editor Window Launch

- Implement "Edit" button to open editor window
- Pass recording data to editor
- Close toolbar when editor opens
- Test: Full flow from record to edit

#### Step 7: Editor Layout Redesign

- Restructure `EditorView.tsx` layout
- Create `VideoPreview.tsx` with background support
- Create `PropertiesPanel.tsx` with tabbed interface
- Test: Editor has new layout structure

#### Step 8: Properties Panel Details

- Implement cursor settings section
- Implement animation settings section
- Implement audio settings section
- Implement background settings section
- Test: All settings render and are interactive

#### Step 9: Timeline Enhancement

- Create new `Timeline.tsx` component
- Add waveform visualization placeholder
- Add playback controls
- Test: Timeline is functional

#### Step 10: Polish & Integration

- Clean up unused code
- Fix any remaining bugs
- Ensure consistent styling
- Test: Full end-to-end flow works

---

### Verification Plan

After each step, verify:

1. `cargo check` passes
2. `bun run build` passes
3. `bun run tauri:dev` runs without errors
4. The specific feature works as described

Final verification:

1. **Recording Toolbar:** Launches as floating window, all controls work
2. **Recording Flow:** Start -> Record -> Stop -> Popup appears
3. **Post-Recording:** Edit button opens full editor
4. **Editor:** Shows recording preview with timeline and properties

---

## Overview

This plan covers the complete MVP implementation (Phases 0-11) for Open ScreenStudio, a Tauri + Rust screen recording application with React frontend. Development will target both macOS and Windows from the start.

**Timeline:** ~14 weeks as outlined in TECHNICAL_PLAN.md  
**Package Manager:** Bun (instead of npm for faster installs)  
**Reference:** `example-project.screenstudio/` contains sample project file format

---

## Phase 0: Project Setup (Week 1) - COMPLETED

**Status:** Done  
**Goal:** Working Tauri app with basic UI

### Learnings & Decisions

1. **Bun over npm** - Using Bun for package management (faster installs, native TypeScript)
   - `bun install` instead of `npm install`
   - Updated `tauri.conf.json` to use `bun run dev` / `bun run build`
   - CI workflows use `oven-sh/setup-bun@v2`

2. **Manual setup required** - `npm create tauri-app` fails on non-empty directories, so we created files manually

3. **Icons** - Created placeholder PNG icons with Python/PIL. Real icons needed before release.

4. **Rust dependencies** - Using latest versions:
   - `core-foundation = "0.10"` (not 0.9)
   - `core-graphics = "0.24"` (not 0.23)
   - `cocoa = "0.26"` for macOS UI integration

### What Was Created

**Frontend:**

- `src/App.tsx` - Main app with sidebar navigation
- `src/components/recording/RecordingView.tsx` - Recording UI with source selection, toggles
- `src/components/editor/EditorView.tsx` - Timeline editor placeholder
- `src/components/export/ExportView.tsx` - Export presets and settings
- `src/stores/projectStore.ts` - Zustand store for project state
- `src/types/project.ts` - Full TypeScript types matching .osp format

**Backend:**

- `src-tauri/src/lib.rs` - Tauri app initialization with plugins
- `src-tauri/src/commands/project.rs` - Project CRUD commands
- `src-tauri/src/commands/system.rs` - System info, display enumeration
- `src-tauri/src/project/schema.rs` - Rust types matching TS types
- `src-tauri/src/project/bundle.rs` - .osp bundle read/write
- `src-tauri/src/utils/error.rs` - Error handling

**Config:**

- `package.json` - Bun-compatible, all dependencies
- `src-tauri/Cargo.toml` - Platform-specific dependencies
- `src-tauri/tauri.conf.json` - Uses Bun commands
- `.github/workflows/ci.yml` - Uses Bun
- `.github/workflows/release.yml` - Uses Bun

### Verification

```bash
bun run tauri:dev  # App opens with working UI
```

---

## Phase 1: Multi-Channel Recording Infrastructure (Weeks 2-3) - COMPLETED

**Status:** Done  
**Goal:** Recording coordinator with screen capture (macOS + Windows)  
**Prerequisites:** FFmpeg installed (`brew install ffmpeg` on macOS)

### Learnings & Decisions

1. **Avoided ffmpeg-next crate** - Instead of using the complex `ffmpeg-next` Rust bindings, we shell out to FFmpeg CLI via `std::process::Command`. This is simpler, more reliable, and leverages the user's existing FFmpeg installation.

2. **Avoided ScreenCaptureKit crate** - The `screencapturekit` Rust crate has Swift runtime dependency issues (`libswift_Concurrency.dylib` not found on some systems). Used `CGDisplay::screenshot()` from `core-graphics` crate instead - simpler and more compatible.

3. **Single MP4 instead of HLS segments** - HLS segment muxer produced files incompatible with QuickTime. Simplified to single `recording-{session}.mp4` files with `-movflags +faststart` for streaming compatibility. Can implement proper HLS later if needed.

4. **Retina display resolution** - On macOS, `CGDisplay::bounds()` returns logical resolution (e.g., 1512x982), but `CGDisplay::screenshot()` returns native pixel resolution (e.g., 3024x1964). Must capture first frame to determine actual dimensions before configuring FFmpeg.

5. **Windows uses GDI BitBlt** - Simpler than Windows.Graphics.Capture API. Uses `EnumDisplayMonitors`, `BitBlt`, and `GetDIBits` for cross-compatible screen capture.

6. **FFmpeg encoding settings that work:**

   ```
   -c:v libx264 -preset veryfast -pix_fmt yuv420p -crf 18 -movflags +faststart
   ```

   - `pix_fmt yuv420p` required for QuickTime compatibility
   - `crf 18` for high quality (lower = better)
   - `veryfast` preset balances speed and quality

7. **Async with tokio** - Recording loop runs in `tokio::spawn` task. Uses `AtomicBool` for stop signal and `parking_lot::Mutex` for thread-safe state.

### What Was Created

**Recorder Module:**

- `src-tauri/src/recorder/mod.rs` - Module exports
- `src-tauri/src/recorder/channel.rs` - `RecordingChannel` trait with async methods
- `src-tauri/src/recorder/coordinator.rs` - `RecordingCoordinator` managing channels
- `src-tauri/src/recorder/state.rs` - `RecordingState`, `RecordingConfig`, `RecordingResult`

**Capture Module:**

- `src-tauri/src/capture/mod.rs` - Platform-conditional exports
- `src-tauri/src/capture/traits.rs` - `DisplayInfo` struct, permission functions
- `src-tauri/src/capture/macos/mod.rs` - macOS module
- `src-tauri/src/capture/macos/screen.rs` - `DisplayCaptureChannel` using CGDisplay + FFmpeg
- `src-tauri/src/capture/macos/permissions.rs` - `CGPreflightScreenCaptureAccess` FFI
- `src-tauri/src/capture/windows/mod.rs` - Windows module
- `src-tauri/src/capture/windows/screen.rs` - `DisplayCaptureChannel` using GDI BitBlt + FFmpeg

**Commands:**

- `src-tauri/src/commands/recording.rs` - Tauri commands for recording control

**Frontend:**

- `src/components/recording/RecordingView.tsx` - Connected to Tauri backend

### Key Dependencies Added

```toml
# Cargo.toml additions
async-trait = "0.1"
parking_lot = "0.12"
tempfile = "3"

[target.'cfg(target_os = "macos")'.dependencies]
core-graphics = "0.24"  # For CGDisplay::screenshot

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = [
    "Win32_Foundation",
    "Win32_Graphics_Gdi",
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_LibraryLoader",
] }
```

### Verification - PASSED

1. **macOS recording works:**
   - Permission prompt appears on first use
   - Display dropdown shows real displays
   - Recording creates `/tmp/open-screenstudio-{timestamp}/recording-0.mp4`
   - Video plays in QuickTime at full Retina resolution

2. **FFmpeg encoding:**
   - Frames piped via stdin at 30fps
   - Output is valid H.264 MP4

### Files Modified

- `src-tauri/src/lib.rs` - Added `capture`, `recorder` modules and commands
- `src-tauri/Cargo.toml` - Added dependencies
- `src/components/recording/RecordingView.tsx` - Connected to Tauri

---

## Phase 2: Audio Channels (Week 4) - COMPLETED

**Status:** Done  
**Goal:** Add audio recording channels (system audio + microphone)

### Approach

Following Phase 1 learnings, we'll use platform APIs for capture and FFmpeg for encoding:

- **Capture audio to raw PCM** using platform APIs
- **Pipe to FFmpeg** for AAC encoding (same pattern as video)
- **Sync via timestamps** - all channels share process start time

### 2.1 macOS System Audio

**Option A: ScreenCaptureKit Audio (preferred)**

- Already have `core-graphics` - can add ScreenCaptureKit for audio
- `SCStreamConfiguration.capturesAudio = true`
- Receives `CMSampleBuffer` with audio data
- Issue: May have same Swift runtime issues as video capture

**Option B: BlackHole/Soundflower (fallback)**

- Require user to install virtual audio device
- Capture via CoreAudio as standard input device

**Recommendation:** Try Option A first with `objc2` bindings, fall back to Option B

### 2.2 macOS Microphone

Use `cpal` crate (cross-platform audio I/O):

```toml
cpal = "0.15"
```

- Enumerate input devices via `cpal::default_host()`
- Open stream on selected device
- Receive PCM samples in callback
- Pipe to FFmpeg for encoding

### 2.3 Windows System Audio

Use WASAPI loopback capture via `windows` crate:

```toml
windows = { features = ["Win32_Media_Audio", "Win32_System_Com"] }
```

- `IAudioClient::Initialize` with `AUDCLNT_STREAMFLAGS_LOOPBACK`
- Captures system audio output
- Get samples via `IAudioCaptureClient`

### 2.4 Windows Microphone

Use `cpal` crate (same as macOS):

- Cross-platform API
- Same code for both platforms

### 2.5 FFmpeg Audio Encoding

Create `AudioEncoder` similar to video:

```rust
// FFmpeg command for audio
ffmpeg -f f32le -ar 48000 -ac 2 -i - -c:a aac -b:a 192k output.m4a
```

Parameters:

- `-f f32le` - 32-bit float little-endian PCM (cpal default)
- `-ar 48000` - 48kHz sample rate
- `-ac 2` - Stereo
- `-c:a aac` - AAC codec
- `-b:a 192k` - 192kbps bitrate

### 2.6 Audio Channel Implementation

Create `src-tauri/src/capture/audio.rs`:

```rust
pub struct AudioCaptureChannel {
    device_id: Option<String>,  // None = default device
    channel_type: AudioChannelType,  // SystemAudio or Microphone
    encoder: Option<Arc<AudioEncoder>>,
    // ...
}

impl RecordingChannel for AudioCaptureChannel {
    // Similar to DisplayCaptureChannel
}
```

### 2.7 Audio/Video Sync Strategy

1. **Recording start:** All channels record `process_start_time = Instant::now()`
2. **Each frame/sample:** Calculate `timestamp_ms = start.elapsed().as_millis()`
3. **FFmpeg muxing:** Use timestamps when combining audio + video in export phase
4. **Separate files for now:** `recording-0.mp4` (video), `recording-0-audio.m4a` (system), `recording-0-mic.m4a` (mic)

### 2.8 Frontend Audio UI

Update `RecordingView.tsx`:

- Microphone device dropdown (enumerate via Tauri command)
- System audio toggle (already exists)
- Audio level meter (future - requires real-time level data)

### Files to Create/Modify

**New files:**

- `src-tauri/src/capture/audio.rs` - `AudioCaptureChannel`
- `src-tauri/src/capture/macos/audio.rs` - macOS system audio capture
- `src-tauri/src/capture/windows/audio.rs` - Windows WASAPI loopback

**Modified files:**

- `src-tauri/Cargo.toml` - Add `cpal = "0.15"`
- `src-tauri/src/capture/mod.rs` - Export audio module
- `src-tauri/src/commands/recording.rs` - Add `get_audio_devices` command
- `src/components/recording/RecordingView.tsx` - Audio device selection

### Verification

1. **Microphone recording:**
   - Select microphone from dropdown
   - Record with mic enabled
   - Check `recording-0-mic.m4a` plays with audio

2. **System audio recording:**
   - Enable system audio toggle
   - Play music during recording
   - Check `recording-0-audio.m4a` captures system sound

3. **Sync test:**
   - Record video + system audio
   - Export/combine manually with FFmpeg
   - Verify audio/video are in sync

**Deliverable:** Record screen with separate audio tracks

### What Was Implemented

**Audio Module (`src-tauri/src/capture/audio.rs`):**

- `AudioEncoder` - FFmpeg-based encoder for audio (pipes f32le PCM to AAC in M4A)
- `MicrophoneCaptureChannel` - Captures from any input device via cpal
- `get_audio_input_devices()` - Enumerate microphones
- Background thread pattern for cpal stream (not Send-safe)

**System Audio (`src-tauri/src/capture/macos/system_audio.rs`):**

- Detects virtual loopback devices (BlackHole, Soundflower)
- Uses loopback device if available, logs warning if not
- Gracefully skips if no loopback device found

**System Audio (`src-tauri/src/capture/windows/system_audio.rs`):**

- Uses WASAPI loopback to capture system audio output
- Captures from default output device

**Commands:**

- `get_audio_devices` - Returns list of microphones

**Frontend:**

- Microphone device dropdown in RecordingView
- Passes selected mic device ID to backend

### Verification - PASSED

1. **Microphone recording works:**
   - Device dropdown shows real microphones
   - Recording creates `recording-0-mic.m4a`
   - Audio file plays correctly

2. **System audio:**
   - Currently requires BlackHole (external tool) - NOT ACCEPTABLE
   - Need to implement native ScreenCaptureKit solution

---

## Phase 2.5: Native System Audio with ScreenCaptureKit - NEEDS FIX

**Status:** Implemented but BROKEN - Requires critical fixes  
**Goal:** Replace BlackHole requirement with native ScreenCaptureKit audio capture

### Current Issues (User Reported)

1. **AirPods stop receiving audio** - When recording starts, Bluetooth audio stops working (but speakers work)
2. **System audio is distorted** - Very low quality, garbled sound in output file
3. **Microphone produces empty audio** - Recording file exists but is silent

### Root Cause Analysis

#### Issue 1: Non-Interleaved Audio Buffers (CRITICAL)

ScreenCaptureKit can output audio in two formats:

- **Interleaved**: 1 buffer with `number_channels == 2`, samples as `LRLRLRLR...`
- **Non-interleaved**: 2 buffers each with `number_channels == 1`, separate `LLLL...` and `RRRR...`

**Current broken code** (`system_audio.rs:45-51`):

```rust
for buffer_ref in audio_buffer_list.iter() {
    let data = buffer_ref.data();
    if !data.is_empty() {
        encoder.write_samples(data);  // WRONG: writes each channel separately
    }
}
```

FFmpeg expects interleaved stereo (`LRLRLR...`), but this code writes buffers sequentially (`LLLL...RRRR...`), producing:

- Double-speed playback on one channel
- Severe distortion
- Garbled audio

**Fix**: Detect buffer layout and interleave if needed.

#### Issue 2: No Format Validation

The code hardcodes 48kHz/2ch/f32le but doesn't verify ScreenCaptureKit's actual output. If format differs, audio will be corrupted.

**Available format info from `CMFormatDescription`:**

- `audio_sample_rate()` - Actual sample rate
- `audio_channel_count()` - Actual channel count
- `audio_bits_per_channel()` - Bit depth
- `audio_is_float()` - Float vs integer samples
- `audio_is_big_endian()` - Endianness

#### Issue 3: AirPods/Bluetooth Audio Routing

ScreenCaptureKit creates a system-wide audio tap that can interfere with Bluetooth audio's exclusive mode. This is a known macOS limitation.

#### Issue 4: Missing Error Handler

No `SCStreamDelegate` for error callbacks - errors during capture are silently ignored.

### Implementation Fix Plan

#### Step 1: Fix Audio Interleaving (CRITICAL)

**File:** `src-tauri/src/capture/macos/system_audio.rs`

Add helper function to interleave non-interleaved stereo:

```rust
/// Interleave non-interleaved stereo audio buffers (f32 samples)
/// Input: Two buffers [L0,L1,L2,...] and [R0,R1,R2,...]
/// Output: Interleaved bytes [L0,R0,L1,R1,L2,R2,...]
fn interleave_stereo_f32(left: &[u8], right: &[u8]) -> Vec<u8> {
    let sample_count = left.len() / 4;  // f32 = 4 bytes
    let mut interleaved = Vec::with_capacity(left.len() + right.len());

    for i in 0..sample_count {
        let offset = i * 4;
        interleaved.extend_from_slice(&left[offset..offset + 4]);
        interleaved.extend_from_slice(&right[offset..offset + 4]);
    }

    interleaved
}
```

Update `process_audio_buffers` to handle both formats:

```rust
fn process_audio_buffers(&self, audio_buffer_list: &AudioBufferList, format_desc: Option<&CMFormatDescription>) {
    let num_buffers = audio_buffer_list.num_buffers();

    if let Some(encoder) = self.encoder.lock().as_ref() {
        match num_buffers {
            0 => { /* nothing to process */ }
            1 => {
                // Single buffer: already interleaved
                if let Some(buffer) = audio_buffer_list.get(0) {
                    let data = buffer.data();
                    if !data.is_empty() {
                        encoder.write_samples(data);
                    }
                }
            }
            2 => {
                // Two buffers: non-interleaved stereo - MUST INTERLEAVE
                let left = audio_buffer_list.get(0).map(|b| b.data());
                let right = audio_buffer_list.get(1).map(|b| b.data());

                if let (Some(left_data), Some(right_data)) = (left, right) {
                    if !left_data.is_empty() && left_data.len() == right_data.len() {
                        let interleaved = Self::interleave_stereo_f32(left_data, right_data);
                        encoder.write_samples(&interleaved);
                    }
                }
            }
            n => {
                // Multi-channel: downmix to stereo using first two
                tracing::warn!("Multi-channel audio ({} buffers) - using first two", n);
                // Same as case 2
            }
        }
    }
}
```

#### Step 2: Add Format Logging and Validation

Add atomic flag to log format once:

```rust
struct AudioOutputHandler {
    encoder: Arc<ParkingMutex<Option<Arc<AudioEncoder>>>>,
    is_recording: Arc<AtomicBool>,
    sample_count: Arc<AtomicU64>,
    format_logged: AtomicBool,  // NEW
}
```

Log format info on first buffer:

```rust
fn log_audio_format(&self, audio_buffer_list: &AudioBufferList, format_desc: Option<&CMFormatDescription>) {
    let num_buffers = audio_buffer_list.num_buffers();
    let first_buffer = audio_buffer_list.get(0);

    let channels_per_buffer = first_buffer.map(|b| b.number_channels).unwrap_or(0);
    let bytes_per_buffer = first_buffer.map(|b| b.data_bytes_size).unwrap_or(0);
    let is_interleaved = num_buffers == 1 && channels_per_buffer >= 2;

    if let Some(fd) = format_desc {
        tracing::info!(
            "SCK audio: buffers={}, ch/buf={}, bytes/buf={}, rate={:?}Hz, ch={:?}, bits={:?}, float={}, be={}, interleaved={}",
            num_buffers, channels_per_buffer, bytes_per_buffer,
            fd.audio_sample_rate(), fd.audio_channel_count(), fd.audio_bits_per_channel(),
            fd.audio_is_float(), fd.audio_is_big_endian(), is_interleaved
        );
    }
}
```

#### Step 3: Add Bluetooth Audio Warning

**File:** `src-tauri/src/capture/macos/system_audio.rs`

Add warning when starting capture:

```rust
// In start() method, before starting stream:
tracing::warn!(
    "System audio capture via ScreenCaptureKit may interfere with Bluetooth audio devices. \
     If you experience audio issues with AirPods/Bluetooth, try using wired speakers."
);
```

#### Step 4: Investigate Microphone Issue

**IMPORTANT**: User confirmed microphone stopped working AFTER the ScreenCaptureKit change. This suggests a conflict.

**Possible causes:**

1. **ScreenCaptureKit may be interfering with cpal** - Both may be competing for audio system resources
2. **Async/threading conflict** - The SCK audio callback may be blocking or interfering with cpal's thread
3. **Sample rate conflict** - Both using 48kHz but SCK might lock the audio system

**Investigation steps:**

1. Add logging to verify mic stream is actually starting
2. Check if mic data callback is being called (add counter)
3. Try starting mic capture BEFORE SCK stream
4. Consider whether SCK's audio tap is capturing mic audio too (interference)

**File:** `src-tauri/src/capture/audio.rs`

Add diagnostic logging:

```rust
// In MicrophoneCaptureChannel::start() - before building stream
tracing::info!(
    "Starting microphone stream: format={:?}, rate={}, ch={}",
    sample_format,
    stream_config.sample_rate.0,
    stream_config.channels
);

// In the audio callback
let callback_count = Arc::new(AtomicU64::new(0));
let cc = callback_count.clone();
// ... in callback:
let count = cc.fetch_add(1, Ordering::Relaxed);
if count % 100 == 0 {
    tracing::debug!("Mic callback #{}, {} bytes", count, data.len());
}
```

#### Step 5: Fix AirPods/Bluetooth Audio Routing

**IMPORTANT**: User confirmed AirPods went COMPLETELY SILENT (not distorted) when recording started. This is a system audio routing issue, not a format issue.

**Root cause**: ScreenCaptureKit's audio capture creates a system-wide audio tap. This tap may be:

1. Capturing audio before it reaches the Bluetooth output
2. Or causing macOS to route audio differently

**Potential fixes:**

**Option A: Use application-specific capture instead of display-wide**

Instead of capturing all system audio from a display:

```rust
// Current (display-wide):
let filter = SCContentFilter::create()
    .with_display(display)
    .with_excluding_windows(&[])
    .build();
```

Try capturing specific applications:

```rust
// Application-specific (less intrusive):
let filter = SCContentFilter::create()
    .with_applications(&apps_to_capture, include_menu_bar)
    .build();
```

**Option B: Check if `excludes_current_process_audio` is enough**

The current code has:

```rust
.with_excludes_current_process_audio(true)
```

But this may not be sufficient for Bluetooth routing.

**Option C: Make system audio capture optional with clear warning**

If SCK system audio inherently conflicts with Bluetooth, warn users:

```rust
if system_audio_enabled {
    tracing::warn!(
        "System audio capture may cause Bluetooth audio (AirPods, etc.) to stop working. \
         Disable system audio capture if you need Bluetooth audio during recording."
    );
}
```

**Option D: Test if stopping SCK stream restores audio**

After recording stops, verify that Bluetooth audio resumes. If not, there may be a cleanup issue.

### Files to Modify

| File                                          | Changes                                             | Priority |
| --------------------------------------------- | --------------------------------------------------- | -------- |
| `src-tauri/src/capture/macos/system_audio.rs` | Add interleaving, format logging, Bluetooth warning | CRITICAL |
| `src-tauri/src/capture/audio.rs`              | Add diagnostic logging for microphone               | HIGH     |
| `src-tauri/src/commands/recording.rs`         | Consider starting mic before SCK                    | MEDIUM   |

### Implementation Order

1. **Fix interleaving** (system_audio.rs) - This is the root cause of distorted audio
2. **Add format logging** (system_audio.rs) - To verify the fix and understand actual format
3. **Add mic diagnostics** (audio.rs) - To understand why mic stopped working
4. **Test and iterate** - May need to adjust channel start order

### Testing Plan

1. **Build and run**: `bun run tauri:dev`
2. **Check logs**: Look for "SCK audio:" format info in console
3. **Test system audio only**: Record WITHOUT mic, verify system audio is clear
4. **Test mic only**: Record WITHOUT system audio, verify mic works
5. **Test both together**: Record with both, check for conflicts
6. **Test AirPods**: Document behavior (may be unfixable due to macOS limitations)

### Verification Checklist

- [ ] System audio output file has correct stereo audio (not distorted)
- [ ] Microphone output file has audio (not silent) when recorded alone
- [ ] Console shows format logging on first audio buffer
- [ ] No crashes during recording
- [ ] Audio/video sync is maintained
- [ ] Document AirPods behavior (may need user warning)

### Fallback Plan

If ScreenCaptureKit continues to cause issues with microphone and Bluetooth:

1. **Option A**: Make system audio capture opt-in with clear warning about conflicts
2. **Option B**: Revert to BlackHole approach for users who need reliable audio
3. **Option C**: Investigate alternative macOS audio capture methods (CoreAudio aggregate devices)

### Code Snippets for Implementation

#### Complete `AudioOutputHandler` rewrite:

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};

struct AudioOutputHandler {
    encoder: Arc<ParkingMutex<Option<Arc<AudioEncoder>>>>,
    is_recording: Arc<AtomicBool>,
    sample_count: Arc<AtomicU64>,
    format_logged: AtomicBool,
}

impl AudioOutputHandler {
    fn new(
        encoder: Arc<ParkingMutex<Option<Arc<AudioEncoder>>>>,
        is_recording: Arc<AtomicBool>,
        sample_count: Arc<AtomicU64>,
    ) -> Self {
        Self {
            encoder,
            is_recording,
            sample_count,
            format_logged: AtomicBool::new(false),
        }
    }

    /// Interleave non-interleaved stereo audio buffers (f32 samples)
    fn interleave_stereo_f32(left: &[u8], right: &[u8]) -> Vec<u8> {
        let sample_count = left.len() / 4;
        let mut interleaved = Vec::with_capacity(left.len() + right.len());

        for i in 0..sample_count {
            let offset = i * 4;
            interleaved.extend_from_slice(&left[offset..offset + 4]);
            interleaved.extend_from_slice(&right[offset..offset + 4]);
        }

        interleaved
    }

    fn log_audio_format(&self, list: &AudioBufferList, fd: Option<&CMFormatDescription>) {
        let num_buffers = list.num_buffers();
        let first = list.get(0);
        let ch_per_buf = first.map(|b| b.number_channels).unwrap_or(0);
        let bytes = first.map(|b| b.data_bytes_size).unwrap_or(0);
        let interleaved = num_buffers == 1 && ch_per_buf >= 2;

        if let Some(f) = fd {
            tracing::info!(
                "SCK audio format: bufs={}, ch/buf={}, bytes={}, rate={:?}, bits={:?}, float={}, interleaved={}",
                num_buffers, ch_per_buf, bytes,
                f.audio_sample_rate(), f.audio_bits_per_channel(),
                f.audio_is_float(), interleaved
            );
        } else {
            tracing::info!(
                "SCK audio: bufs={}, ch/buf={}, bytes={}, interleaved={} (no format desc)",
                num_buffers, ch_per_buf, bytes, interleaved
            );
        }
    }

    fn process_audio(&self, list: &AudioBufferList, fd: Option<&CMFormatDescription>) {
        // Log format once
        if !self.format_logged.swap(true, Ordering::Relaxed) {
            self.log_audio_format(list, fd);
        }

        let num_buffers = list.num_buffers();

        if let Some(encoder) = self.encoder.lock().as_ref() {
            match num_buffers {
                0 => {}
                1 => {
                    // Already interleaved
                    if let Some(buf) = list.get(0) {
                        let data = buf.data();
                        if !data.is_empty() {
                            encoder.write_samples(data);
                            self.sample_count.fetch_add((data.len() / 4) as u64, Ordering::Relaxed);
                        }
                    }
                }
                _ => {
                    // Non-interleaved: need to interleave first two channels
                    let left = list.get(0).map(|b| b.data());
                    let right = list.get(1).map(|b| b.data());

                    if let (Some(l), Some(r)) = (left, right) {
                        if !l.is_empty() && l.len() == r.len() {
                            let interleaved = Self::interleave_stereo_f32(l, r);
                            encoder.write_samples(&interleaved);
                            self.sample_count.fetch_add((interleaved.len() / 4) as u64, Ordering::Relaxed);
                        }
                    }
                }
            }
        }
    }
}

impl SCStreamOutputTrait for AudioOutputHandler {
    fn did_output_sample_buffer(&self, sample: CMSampleBuffer, of_type: SCStreamOutputType) {
        if of_type != SCStreamOutputType::Audio || !self.is_recording.load(Ordering::Relaxed) {
            return;
        }

        if let Some(list) = sample.audio_buffer_list() {
            self.process_audio(&list, sample.format_description().as_ref());
        }
    }
}
```

#### Microphone diagnostic logging:

```rust
// In audio.rs, MicrophoneCaptureChannel::start()

// Add callback counter for debugging
let callback_counter = Arc::new(AtomicU64::new(0));

// In the build_input_stream callback:
let count = callback_counter.fetch_add(1, Ordering::Relaxed);
if count == 0 {
    tracing::info!("First mic callback received - mic capture working");
}
if count % 500 == 0 && count > 0 {
    tracing::debug!("Mic callbacks: {}", count);
}
```

---

## Phase 3: Input Tracking Channel (Week 5) - NEXT

**Goal:** High-frequency mouse input capture (no keystrokes)  
**Scope decisions:**

- Mouse only (privacy) ✅
- Polling target: 120Hz ✅
- Platform focus: macOS first, Windows later

### Learnings Applied (from Phases 1–2.5)

- **Match actual runtime formats**: Like ScreenCaptureKit audio buffers, input/cursor data can come in multiple layouts; add one-time logging and validate assumptions early.
- **Avoid expensive work in callbacks**: Buffer in memory; do file I/O only on `stop()`.
- **Non-Send resources**: Follow the microphone pattern (background thread + `Arc<AtomicBool>` stop flag).
- **Permissions are first-class**: As with Screen Recording, input monitoring requires explicit user permission on macOS.

### 3.1 Output Files (per session)

**Decision:** Cursor images stored as PNG files ✅

Write files under the per-recording `recording/` folder (same pattern as audio/video):

- `recording-{session}-mouse-moves.json`
- `recording-{session}-mouse-clicks.json`
- `recording-{session}-cursors.json`
- `recording-{session}-cursors/` (PNG images)

Note: `src/types/project.ts` includes `keystrokesFile` in `InputChannelSession`, but we will **not** generate it for now. We can leave it empty/omitted in metadata until a privacy-safe approach is decided.

### 3.2 Rust Data Structures

Create `src-tauri/src/capture/input/types.rs`:

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MouseMove {
    pub x: f64,
    pub y: f64,
    pub cursor_id: String,
    pub active_modifiers: Vec<String>,
    pub process_time_ms: f64,
    pub unix_time_ms: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MouseClick {
    pub x: f64,
    pub y: f64,
    pub button: String,     // "left" | "right" | "middle"
    pub event_type: String, // "down" | "up"
    pub click_count: u32,
    pub active_modifiers: Vec<String>,
    pub process_time_ms: f64,
    pub unix_time_ms: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CursorInfo {
    pub id: String,
    pub image_path: String, // relative path under `recording/`
    pub hotspot_x: f64,
    pub hotspot_y: f64,
    pub width: u32,
    pub height: u32,
}
```

### 3.3 InputTrackingChannel

Create `src-tauri/src/capture/input/channel.rs` implementing `RecordingChannel`:

- Maintain buffers in memory:
  - `Vec<MouseMove>`, `Vec<MouseClick>`, `HashMap<String, CursorInfo>`
- Start a background thread that:
  - Polls mouse position at 120Hz (~8.33ms)
  - Captures click events via a platform hook/tap
  - Captures cursor image only when cursor changes
- On `stop()`:
  - Stop thread
  - Serialize buffers to JSON
  - Write cursor PNGs and `cursors.json`
  - Push file paths into `output_files`

### 3.4 macOS Implementation

Create `src-tauri/src/capture/macos/input.rs`.

**Permissions**:

- macOS requires **Input Monitoring / Accessibility** permission for global event taps.
- Add a new permission check/request flow similar to screen recording (even if the API is limited, at minimum detect and error with actionable message).

**Event collection approach**:

- Use **CGEventTap** (preferred) for click events + modifier state.
- Use **polling** at 120Hz for mouse moves (stable and easy to tune).
- Use `NSCursor` (via `objc2-app-kit`) to capture cursor images + hotspot.

**One-time diagnostics**:

- On start, log: poll interval, initial cursor id, and whether event tap was successfully installed.

### 3.5 Windows Implementation (Deferred)

Create stubs in `src-tauri/src/capture/windows/input.rs` and wire later:

- Mouse position: `GetCursorPos` polling
- Clicks: low-level hook `SetWindowsHookEx(WH_MOUSE_LL, ...)`
- Cursor: `GetCursorInfo` + bitmap export

### 3.6 Wiring Into Recording

**Decision:** Input tracking is always ON for MVP ✅

Update `src-tauri/src/commands/recording.rs`:

- Always add `InputTrackingChannel` when recording starts.

Update `src-tauri/src/capture/mod.rs`:

- Export `capture::input` module.

### 3.7 Dependencies

Likely needed:

- `png = "0.17"` (encode cursor images)

macOS already has:

- `core-graphics`, `objc2-app-kit`.

Windows may require adding `windows` features later.

### Verification

1. `bun run tauri:dev`
2. Start recording, move mouse ~5s, click a few times, stop.
3. Verify files exist under the output `recording/` folder:
   - `recording-0-mouse-moves.json` has ~600 entries for 5 seconds.
   - `recording-0-mouse-clicks.json` has expected click up/down.
   - `recording-0-cursors.json` exists and `recording-0-cursors/` contains PNG(s).

**Deliverable:** Reliable macOS mouse/cursor capture suitable for Phase 5/6 processing.

---

## Phase 3 Fix: objc2 Feature Flags (BLOCKING)

**Status:** Compilation fails - missing Cargo feature flags

### Problem

The `objc2-app-kit` and `objc2-foundation` crates use feature flags to conditionally compile each class. Current `Cargo.toml` doesn't enable them:

```
error[E0432]: unresolved imports `objc2_app_kit::NSCursor`, `objc2_app_kit::NSEvent`, etc.
error[E0432]: unresolved imports `objc2_foundation::NSDictionary`
error[E0412]: cannot find type `NSEventModifierFlags`
```

### Fix Plan

#### Step 1: Update `src-tauri/Cargo.toml` (lines 51-53)

**Before:**

```toml
objc2 = "0.5"
objc2-foundation = "0.2"
objc2-app-kit = "0.2"
```

**After:**

```toml
objc2 = "0.5"
objc2-foundation = { version = "0.2", features = ["NSDictionary", "NSData", "NSGeometry", "NSObject"] }
objc2-app-kit = { version = "0.2", features = ["NSCursor", "NSEvent", "NSImage", "NSBitmapImageRep"] }
```

#### Step 2: Fix imports in `src-tauri/src/capture/macos/input.rs`

**Change line 5:**

```rust
// Before:
use objc2_foundation::{AnyObject, NSDictionary};

// After:
use objc2::runtime::AnyObject;
use objc2_foundation::NSDictionary;
```

#### Step 3: Fix `NSEvent::modifierFlags()` call (line 63)

In objc2-app-kit v0.2.2, `modifierFlags()` is a class method named `modifierFlags_class()`:

```rust
// Before (line 63):
let modifiers = modifiers_from_flags(unsafe { NSEvent::modifierFlags() });

// After:
let modifiers = modifiers_from_flags(unsafe { NSEvent::modifierFlags_class() });
```

#### Step 4: Fix `NSEventModifierFlags` usage (lines 174-184)

The v0.2.2 `NSEventModifierFlags` is a newtype struct, not a bitflags type. Use the inner value:

```rust
// Before:
fn modifiers_from_flags(flags: objc2_app_kit::NSEventModifierFlags) -> Vec<String> {
    let mut v = Vec::new();
    if flags.contains(objc2_app_kit::NSEventModifierFlags::Shift) {
        v.push("shift".to_string());
    }
    // ...
}

// After:
fn modifiers_from_flags(flags: objc2_app_kit::NSEventModifierFlags) -> Vec<String> {
    use objc2_app_kit::NSEventModifierFlags;
    let mut v = Vec::new();
    // Use bitwise AND with the flag constants
    if (flags.0 & NSEventModifierFlags::NSEventModifierFlagShift.0) != 0 {
        v.push("shift".to_string());
    }
    if (flags.0 & NSEventModifierFlags::NSEventModifierFlagControl.0) != 0 {
        v.push("control".to_string());
    }
    if (flags.0 & NSEventModifierFlags::NSEventModifierFlagOption.0) != 0 {
        v.push("alt".to_string());
    }
    if (flags.0 & NSEventModifierFlags::NSEventModifierFlagCommand.0) != 0 {
        v.push("meta".to_string());
    }
    v
}
```

### Files to Modify

| File                                   | Changes                                    |
| -------------------------------------- | ------------------------------------------ |
| `src-tauri/Cargo.toml`                 | Add feature flags to objc2 deps            |
| `src-tauri/src/capture/macos/input.rs` | Fix imports, method calls, and flag checks |

### Verification

```bash
cd src-tauri && cargo check
bun run tauri:dev
# Start recording, move mouse, stop, check JSON files
```

---

## Phase 4: Webcam Channel (Week 6)

**Goal:** Camera recording

### 4.1 macOS Webcam

- AVFoundation AVCaptureSession
- Device enumeration
- Frame capture to fMP4 segments

### 4.2 Windows Webcam

- Windows.Media.Capture MediaCapture
- Device enumeration
- Frame capture

### 4.3 Webcam UI

- Camera preview overlay
- Device selection dropdown
- Enable/disable toggle
- Mirror option

**Deliverable:** Record with webcam overlay

---

## Phase 5: Cursor Smoothing (Week 7)

**Goal:** Smooth cursor movement in playback

### 5.1 Spring Physics Implementation

`src-tauri/src/processing/spring.rs`:

```rust
pub struct SpringConfig {
    pub stiffness: f64,
    pub damping: f64,
    pub mass: f64,
}

pub fn simulate_spring(current: f64, target: f64, velocity: &mut f64, config: &SpringConfig, dt: f64) -> f64
```

### 5.2 Cursor Smoothing Algorithm

`src-tauri/src/processing/cursor_smooth.rs`:

- Read mouse moves from JSON
- Apply spring physics simulation
- Interpolate at output framerate
- Handle teleporting cursor detection
- Handle screen edge behavior

### 5.3 Smoothing UI

- Enable/disable toggle
- Intensity slider (adjusts spring params)
- Preview in editor

**Deliverable:** Smooth cursor in preview/export

---

## Phase 6: Automatic Zoom (Week 8)

**Goal:** Click-based automatic zoom

### 6.1 Zoom Algorithm

`src-tauri/src/processing/zoom.rs`:

- Click detection from JSON
- Click grouping by time/space proximity
- Zoom region calculation
- Edge snapping

### 6.2 Zoom Types

- `follow-cursor`: Track cursor position
- `follow-clicks`: Center on click locations
- `manual`: Fixed position

### 6.3 Zoom Transitions

- Spring physics for smooth zoom in/out
- Configurable zoom speed
- Instant zoom option

### 6.4 Zoom UI

- Timeline markers for zoom ranges
- Add/edit/delete zoom regions
- Zoom level control
- Zoom type selection

**Deliverable:** Automatic zoom working

---

## Phase 7: Basic Editor (Weeks 9-10)

**Goal:** Timeline-based editing

### 7.1 HLS Player Integration

- hls.js for segment playback
- Seek to any segment
- Frame-accurate playback control

### 7.2 Timeline Component

`src/components/editor/Timeline.tsx`:

- Visual timeline representation
- Segment thumbnails
- Playhead with time display
- Zoom in/out timeline view

### 7.3 Playback Controls

- Play/pause
- Seek (click on timeline)
- Frame step forward/backward
- Playback speed control

### 7.4 Trimming

- Adjust recording range (start/end trim)
- Visual trim handles
- Preview trimmed result

### 7.5 Cutting (Slices)

- Cut to create new slices
- Remove slices
- Reorder slices (future)

### 7.6 Undo/Redo System

- Command pattern for edits
- Zustand middleware or separate undo stack
- Keyboard shortcuts (Cmd/Ctrl+Z, Cmd/Ctrl+Shift+Z)

**Deliverable:** Basic non-destructive editing

---

## Phase 8: Layout System (Week 11)

**Goal:** Camera/screen arrangement

### 8.1 Layout Data Structure

```typescript
interface Layout {
  id: string;
  startTime: number;
  endTime: number;
  type: "screen-only" | "camera-only" | "screen-with-camera" | "side-by-side";
  cameraSize: number;
  cameraPosition: { x: number; y: number };
}
```

### 8.2 Layout Types

- `screen-only`: Full screen, no camera
- `camera-only`: Full camera, no screen
- `screen-with-camera`: Screen with camera overlay (PiP)
- `side-by-side`: Split view

### 8.3 Layout Transitions

- Animated transitions between layouts
- Configurable transition duration

### 8.4 Layout UI

- Layout preset buttons
- Camera position controls (drag or presets)
- Camera size slider
- Timeline keyframe markers

**Deliverable:** Configurable camera layouts

---

## Phase 9: Styling System (Week 12)

**Goal:** Backgrounds and visual polish

### 9.1 Background Options

- Solid colors
- Gradients (linear, radial)
- Images (stretch, fit, fill)

### 9.2 Visual Controls

- Padding/spacing (top, right, bottom, left)
- Corner radius
- Drop shadow (intensity, angle, distance, blur)
- Border

### 9.3 Styling UI

- Color pickers
- Gradient editor
- Padding sliders
- Shadow controls
- Real-time preview

**Deliverable:** Styled output

---

## Phase 10: Export System (Week 13)

**Goal:** Production-ready export

### 10.1 Export Pipeline

`src-tauri/src/export/`:

- Read all segments
- Apply effects (zoom, cursor smoothing, composition)
- Encode to output format

### 10.2 Compositor

`src-tauri/src/processing/compositor.rs`:

- Layer screen, camera, cursor
- Apply backgrounds
- Apply shadows, corners

### 10.3 FFmpeg Integration

`src-tauri/src/export/encoder.rs`:

- ffmpeg-next crate
- MP4 export (H.264/H.265)
- GIF export with optimization
- WebM export (VP9)

### 10.4 Export Presets

- Quality levels (low, medium, high, lossless)
- Resolution options
- Framerate options

### 10.5 Hardware Acceleration

- VideoToolbox (macOS)
- NVENC/AMD (Windows)
- Fallback to software encoding

### 10.6 Export UI

- Format selection
- Quality/preset selection
- Resolution picker
- Progress bar
- Cancel button
- Output file picker

**Deliverable:** Export polished videos

---

## Phase 11: Polish & MVP Release (Week 14)

**Goal:** Ship it!

### 11.1 Bug Fixes

- Edge case handling
- Error recovery
- Crash fixes

### 11.2 Performance Optimization

- Memory profiling
- CPU optimization
- Segment loading optimization

### 11.3 UI Polish

- Animations and transitions
- Loading states
- Error states
- Empty states

### 11.4 Documentation

- User guide
- Keyboard shortcuts reference
- FAQ

### 11.5 Release Builds

- macOS universal binary (Intel + Apple Silicon)
- Windows x64 installer
- Code signing (if certificates available)
- Auto-updater setup

**Deliverable:** MVP release v0.1.0

---

## Key Files to Create/Modify

### Phase 0 (Initial Setup)

- `package.json` - Create via Tauri CLI, add dependencies
- `src-tauri/Cargo.toml` - Add Rust dependencies
- `src-tauri/tauri.conf.json` - Configure Tauri app
- `tailwind.config.js` - Tailwind configuration
- `src/types/project.ts` - TypeScript types
- `src/App.tsx` - Main app with routing
- `src/stores/projectStore.ts` - Zustand project store
- `src-tauri/src/project/bundle.rs` - Project bundle I/O
- `src-tauri/src/commands/project.rs` - Tauri commands

### Phase 1-4 (Recording)

- `src-tauri/src/recorder/channel.rs` - Channel trait
- `src-tauri/src/recorder/coordinator.rs` - Recording coordinator
- `src-tauri/src/recorder/segment_writer.rs` - HLS segment writer
- `src-tauri/src/capture/macos/*.rs` - macOS capture implementations
- `src-tauri/src/capture/windows/*.rs` - Windows capture implementations
- `src/components/recording/RecordingView.tsx` - Recording UI

### Phase 5-6 (Processing)

- `src-tauri/src/processing/spring.rs` - Spring physics
- `src-tauri/src/processing/cursor_smooth.rs` - Cursor smoothing
- `src-tauri/src/processing/zoom.rs` - Automatic zoom

### Phase 7-9 (Editing)

- `src/components/editor/EditorView.tsx` - Editor main view
- `src/components/editor/Timeline.tsx` - Timeline component
- `src/components/editor/Preview.tsx` - Preview player
- `src/stores/editorStore.ts` - Editor state

### Phase 10-11 (Export)

- `src-tauri/src/export/encoder.rs` - FFmpeg encoding
- `src-tauri/src/processing/compositor.rs` - Layer composition
- `src/components/export/ExportView.tsx` - Export UI

---

## Verification Plan

### Phase 0 Verification - DONE

1. Run `bun run tauri:dev` - app opens with dark UI
2. Navigate between Record/Edit/Export views
3. Click "New" - creates project in memory
4. UI controls respond (source dropdown, toggles, buttons)

### Phase 1 Verification - PASSED

1. `bun run tauri:dev` - app opens ✓
2. Screen recording permission prompt appears on first record attempt (macOS) ✓
3. Display dropdown shows real system displays ✓
4. Start recording for 5+ seconds, then stop ✓
5. Check `/tmp/open-screenstudio-{timestamp}/recording-0.mp4` exists ✓
6. Play MP4 with QuickTime - video plays at full Retina resolution ✓

### Phase 2-4 Verification

1. Start recording - should create segment files
2. Stop recording - should have valid m3u8 playlist
3. Verify audio sync with video
4. Verify webcam recording

### Phase 5-6 Verification

1. Enable cursor smoothing - cursor should move smoothly in preview
2. Create zoom range - should zoom smoothly to target

### Phase 7-9 Verification

1. Open recorded project in editor
2. Trim, cut, and rearrange slices
3. Change layouts and styling
4. Preview changes in real-time

### Phase 10-11 Verification

1. Export to MP4 - verify playback in VLC
2. Export to GIF - verify animation
3. Verify all effects applied correctly
4. Test on both macOS and Windows

---

## Dependencies Summary

### Rust Crates (src-tauri/Cargo.toml) - ACTUAL

```toml
[dependencies]
# Tauri
tauri = { version = "2", features = ["macos-private-api"] }
tauri-plugin-shell = "2"
tauri-plugin-dialog = "2"
tauri-plugin-fs = "2"

# Async Runtime
tokio = { version = "1", features = ["full"] }

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Error Handling
thiserror = "1"
anyhow = "1"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Utilities
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
async-trait = "0.1"      # Async trait support
parking_lot = "0.12"     # Fast mutex for frame writing
tempfile = "3"           # Temp directory management

# Phase 2+ (planned)
# cpal = "0.15"          # Cross-platform audio I/O

[target.'cfg(target_os = "macos")'.dependencies]
objc2 = "0.5"
objc2-foundation = "0.2"
objc2-app-kit = "0.2"
block2 = "0.5"
core-foundation = "0.10"
core-graphics = "0.24"   # For CGDisplay::screenshot
cocoa = "0.26"
dispatch = "0.2"
# NOTE: Avoided screencapturekit crate due to Swift runtime issues

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = [
    "Win32_Foundation",
    "Win32_Graphics_Gdi",         # For BitBlt screen capture
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_LibraryLoader",
    # Phase 2+ for audio:
    # "Win32_Media_Audio",
    # "Win32_System_Com",
] }
```

### Bun Packages (package.json)

Managed with `bun install`:

```json
{
  "dependencies": {
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "zustand": "^4.5.0",
    "lucide-react": "^0.400.0",
    "@tauri-apps/api": "^2.0.0",
    "@tauri-apps/plugin-dialog": "^2.0.0",
    "@tauri-apps/plugin-fs": "^2.0.0"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2.0.0",
    "typescript": "^5.5.0",
    "vite": "^5.4.0",
    "@vitejs/plugin-react": "^4.3.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0"
  }
}
```

### System Dependencies

**macOS:**

```bash
brew install ffmpeg
```

**Windows:**

- FFmpeg binaries in PATH (download from ffmpeg.org)
- Or bundle FFmpeg with the app

### Key Architecture Decisions

1. **Shell out to FFmpeg CLI** instead of using `ffmpeg-next` crate
   - Simpler, more reliable
   - User's FFmpeg installation handles codec licensing
   - Pipe raw frames/samples via stdin

2. **Platform-specific capture APIs**
   - macOS: `core-graphics` CGDisplay (not ScreenCaptureKit)
   - Windows: GDI BitBlt (not Windows.Graphics.Capture)
   - Simpler, more compatible, fewer dependencies

3. **Separate files per channel**
   - `recording-{session}.mp4` for video
   - `recording-{session}-audio.m4a` for system audio (Phase 2)
   - `recording-{session}-mic.m4a` for microphone (Phase 2)
   - Combined in export phase
