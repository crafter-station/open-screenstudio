# Open ScreenStudio - Full MVP Implementation Plan

## Overview

This plan covers the complete MVP implementation (Phases 0-11) for Open ScreenStudio, a Tauri + Rust screen recording application with React frontend. Development will target both macOS and Windows from the start.

**Timeline:** ~14 weeks as outlined in TECHNICAL_PLAN.md  
**Package Manager:** Bun (instead of npm for faster installs)  
**Reference:** `example-project.screenstudio/` contains sample project file format

---

## Phase 0: Project Setup (Week 1) - COMPLETED

**Status:** Done  
**Goal:** Working Tauri app with basic UI

### Learnings & Decisions

1. **Bun over npm** - Using Bun for package management (faster installs, native TypeScript)
   - `bun install` instead of `npm install`
   - Updated `tauri.conf.json` to use `bun run dev` / `bun run build`
   - CI workflows use `oven-sh/setup-bun@v2`

2. **Manual setup required** - `npm create tauri-app` fails on non-empty directories, so we created files manually

3. **Icons** - Created placeholder PNG icons with Python/PIL. Real icons needed before release.

4. **Rust dependencies** - Using latest versions:
   - `core-foundation = "0.10"` (not 0.9)
   - `core-graphics = "0.24"` (not 0.23)
   - `cocoa = "0.26"` for macOS UI integration

### What Was Created

**Frontend:**

- `src/App.tsx` - Main app with sidebar navigation
- `src/components/recording/RecordingView.tsx` - Recording UI with source selection, toggles
- `src/components/editor/EditorView.tsx` - Timeline editor placeholder
- `src/components/export/ExportView.tsx` - Export presets and settings
- `src/stores/projectStore.ts` - Zustand store for project state
- `src/types/project.ts` - Full TypeScript types matching .osp format

**Backend:**

- `src-tauri/src/lib.rs` - Tauri app initialization with plugins
- `src-tauri/src/commands/project.rs` - Project CRUD commands
- `src-tauri/src/commands/system.rs` - System info, display enumeration
- `src-tauri/src/project/schema.rs` - Rust types matching TS types
- `src-tauri/src/project/bundle.rs` - .osp bundle read/write
- `src-tauri/src/utils/error.rs` - Error handling

**Config:**

- `package.json` - Bun-compatible, all dependencies
- `src-tauri/Cargo.toml` - Platform-specific dependencies
- `src-tauri/tauri.conf.json` - Uses Bun commands
- `.github/workflows/ci.yml` - Uses Bun
- `.github/workflows/release.yml` - Uses Bun

### Verification

```bash
bun run tauri:dev  # App opens with working UI
```

---

## Phase 1: Multi-Channel Recording Infrastructure (Weeks 2-3) - COMPLETED

**Status:** Done  
**Goal:** Recording coordinator with screen capture (macOS + Windows)  
**Prerequisites:** FFmpeg installed (`brew install ffmpeg` on macOS)

### Learnings & Decisions

1. **Avoided ffmpeg-next crate** - Instead of using the complex `ffmpeg-next` Rust bindings, we shell out to FFmpeg CLI via `std::process::Command`. This is simpler, more reliable, and leverages the user's existing FFmpeg installation.

2. **Avoided ScreenCaptureKit crate** - The `screencapturekit` Rust crate has Swift runtime dependency issues (`libswift_Concurrency.dylib` not found on some systems). Used `CGDisplay::screenshot()` from `core-graphics` crate instead - simpler and more compatible.

3. **Single MP4 instead of HLS segments** - HLS segment muxer produced files incompatible with QuickTime. Simplified to single `recording-{session}.mp4` files with `-movflags +faststart` for streaming compatibility. Can implement proper HLS later if needed.

4. **Retina display resolution** - On macOS, `CGDisplay::bounds()` returns logical resolution (e.g., 1512x982), but `CGDisplay::screenshot()` returns native pixel resolution (e.g., 3024x1964). Must capture first frame to determine actual dimensions before configuring FFmpeg.

5. **Windows uses GDI BitBlt** - Simpler than Windows.Graphics.Capture API. Uses `EnumDisplayMonitors`, `BitBlt`, and `GetDIBits` for cross-compatible screen capture.

6. **FFmpeg encoding settings that work:**

   ```
   -c:v libx264 -preset veryfast -pix_fmt yuv420p -crf 18 -movflags +faststart
   ```

   - `pix_fmt yuv420p` required for QuickTime compatibility
   - `crf 18` for high quality (lower = better)
   - `veryfast` preset balances speed and quality

7. **Async with tokio** - Recording loop runs in `tokio::spawn` task. Uses `AtomicBool` for stop signal and `parking_lot::Mutex` for thread-safe state.

### What Was Created

**Recorder Module:**

- `src-tauri/src/recorder/mod.rs` - Module exports
- `src-tauri/src/recorder/channel.rs` - `RecordingChannel` trait with async methods
- `src-tauri/src/recorder/coordinator.rs` - `RecordingCoordinator` managing channels
- `src-tauri/src/recorder/state.rs` - `RecordingState`, `RecordingConfig`, `RecordingResult`

**Capture Module:**

- `src-tauri/src/capture/mod.rs` - Platform-conditional exports
- `src-tauri/src/capture/traits.rs` - `DisplayInfo` struct, permission functions
- `src-tauri/src/capture/macos/mod.rs` - macOS module
- `src-tauri/src/capture/macos/screen.rs` - `DisplayCaptureChannel` using CGDisplay + FFmpeg
- `src-tauri/src/capture/macos/permissions.rs` - `CGPreflightScreenCaptureAccess` FFI
- `src-tauri/src/capture/windows/mod.rs` - Windows module
- `src-tauri/src/capture/windows/screen.rs` - `DisplayCaptureChannel` using GDI BitBlt + FFmpeg

**Commands:**

- `src-tauri/src/commands/recording.rs` - Tauri commands for recording control

**Frontend:**

- `src/components/recording/RecordingView.tsx` - Connected to Tauri backend

### Key Dependencies Added

```toml
# Cargo.toml additions
async-trait = "0.1"
parking_lot = "0.12"
tempfile = "3"

[target.'cfg(target_os = "macos")'.dependencies]
core-graphics = "0.24"  # For CGDisplay::screenshot

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = [
    "Win32_Foundation",
    "Win32_Graphics_Gdi",
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_LibraryLoader",
] }
```

### Verification - PASSED

1. **macOS recording works:**
   - Permission prompt appears on first use
   - Display dropdown shows real displays
   - Recording creates `/tmp/open-screenstudio-{timestamp}/recording-0.mp4`
   - Video plays in QuickTime at full Retina resolution

2. **FFmpeg encoding:**
   - Frames piped via stdin at 30fps
   - Output is valid H.264 MP4

### Files Modified

- `src-tauri/src/lib.rs` - Added `capture`, `recorder` modules and commands
- `src-tauri/Cargo.toml` - Added dependencies
- `src/components/recording/RecordingView.tsx` - Connected to Tauri

---

## Phase 2: Audio Channels (Week 4) - NEXT

**Status:** Ready to implement  
**Goal:** Add audio recording channels (system audio + microphone)

### Approach

Following Phase 1 learnings, we'll use platform APIs for capture and FFmpeg for encoding:

- **Capture audio to raw PCM** using platform APIs
- **Pipe to FFmpeg** for AAC encoding (same pattern as video)
- **Sync via timestamps** - all channels share process start time

### 2.1 macOS System Audio

**Option A: ScreenCaptureKit Audio (preferred)**

- Already have `core-graphics` - can add ScreenCaptureKit for audio
- `SCStreamConfiguration.capturesAudio = true`
- Receives `CMSampleBuffer` with audio data
- Issue: May have same Swift runtime issues as video capture

**Option B: BlackHole/Soundflower (fallback)**

- Require user to install virtual audio device
- Capture via CoreAudio as standard input device

**Recommendation:** Try Option A first with `objc2` bindings, fall back to Option B

### 2.2 macOS Microphone

Use `cpal` crate (cross-platform audio I/O):

```toml
cpal = "0.15"
```

- Enumerate input devices via `cpal::default_host()`
- Open stream on selected device
- Receive PCM samples in callback
- Pipe to FFmpeg for encoding

### 2.3 Windows System Audio

Use WASAPI loopback capture via `windows` crate:

```toml
windows = { features = ["Win32_Media_Audio", "Win32_System_Com"] }
```

- `IAudioClient::Initialize` with `AUDCLNT_STREAMFLAGS_LOOPBACK`
- Captures system audio output
- Get samples via `IAudioCaptureClient`

### 2.4 Windows Microphone

Use `cpal` crate (same as macOS):

- Cross-platform API
- Same code for both platforms

### 2.5 FFmpeg Audio Encoding

Create `AudioEncoder` similar to video:

```rust
// FFmpeg command for audio
ffmpeg -f f32le -ar 48000 -ac 2 -i - -c:a aac -b:a 192k output.m4a
```

Parameters:

- `-f f32le` - 32-bit float little-endian PCM (cpal default)
- `-ar 48000` - 48kHz sample rate
- `-ac 2` - Stereo
- `-c:a aac` - AAC codec
- `-b:a 192k` - 192kbps bitrate

### 2.6 Audio Channel Implementation

Create `src-tauri/src/capture/audio.rs`:

```rust
pub struct AudioCaptureChannel {
    device_id: Option<String>,  // None = default device
    channel_type: AudioChannelType,  // SystemAudio or Microphone
    encoder: Option<Arc<AudioEncoder>>,
    // ...
}

impl RecordingChannel for AudioCaptureChannel {
    // Similar to DisplayCaptureChannel
}
```

### 2.7 Audio/Video Sync Strategy

1. **Recording start:** All channels record `process_start_time = Instant::now()`
2. **Each frame/sample:** Calculate `timestamp_ms = start.elapsed().as_millis()`
3. **FFmpeg muxing:** Use timestamps when combining audio + video in export phase
4. **Separate files for now:** `recording-0.mp4` (video), `recording-0-audio.m4a` (system), `recording-0-mic.m4a` (mic)

### 2.8 Frontend Audio UI

Update `RecordingView.tsx`:

- Microphone device dropdown (enumerate via Tauri command)
- System audio toggle (already exists)
- Audio level meter (future - requires real-time level data)

### Files to Create/Modify

**New files:**

- `src-tauri/src/capture/audio.rs` - `AudioCaptureChannel`
- `src-tauri/src/capture/macos/audio.rs` - macOS system audio capture
- `src-tauri/src/capture/windows/audio.rs` - Windows WASAPI loopback

**Modified files:**

- `src-tauri/Cargo.toml` - Add `cpal = "0.15"`
- `src-tauri/src/capture/mod.rs` - Export audio module
- `src-tauri/src/commands/recording.rs` - Add `get_audio_devices` command
- `src/components/recording/RecordingView.tsx` - Audio device selection

### Verification

1. **Microphone recording:**
   - Select microphone from dropdown
   - Record with mic enabled
   - Check `recording-0-mic.m4a` plays with audio

2. **System audio recording:**
   - Enable system audio toggle
   - Play music during recording
   - Check `recording-0-audio.m4a` captures system sound

3. **Sync test:**
   - Record video + system audio
   - Export/combine manually with FFmpeg
   - Verify audio/video are in sync

**Deliverable:** Record screen with separate audio tracks

---

## Phase 3: Input Tracking Channel (Week 5)

**Goal:** High-frequency input capture

### 3.1 Input Data Structures

```rust
pub struct MouseMove {
    pub x: f64,
    pub y: f64,
    pub cursor_id: String,
    pub active_modifiers: Vec<String>,
    pub process_time_ms: f64,
    pub unix_time_ms: u64,
}
```

### 3.2 macOS Input Tracking

- CGEvent for mouse position (~120Hz)
- CGEvent for keyboard events
- CGDisplayCopyCurrentCursor for cursor images

### 3.3 Windows Input Tracking

- GetCursorPos for mouse position
- SetWindowsHookEx for keyboard
- GetCursorInfo for cursor images

### 3.4 JSON Buffer & Flush

- Buffer input events in memory
- Periodic flush to JSON files
- Final flush on recording stop

### 3.5 Cursor Image Capture

- Capture unique cursor images as PNG
- Store cursor metadata (hotspot, size)
- Reference by cursor_id

**Deliverable:** Full input tracking during recording

---

## Phase 4: Webcam Channel (Week 6)

**Goal:** Camera recording

### 4.1 macOS Webcam

- AVFoundation AVCaptureSession
- Device enumeration
- Frame capture to fMP4 segments

### 4.2 Windows Webcam

- Windows.Media.Capture MediaCapture
- Device enumeration
- Frame capture

### 4.3 Webcam UI

- Camera preview overlay
- Device selection dropdown
- Enable/disable toggle
- Mirror option

**Deliverable:** Record with webcam overlay

---

## Phase 5: Cursor Smoothing (Week 7)

**Goal:** Smooth cursor movement in playback

### 5.1 Spring Physics Implementation

`src-tauri/src/processing/spring.rs`:

```rust
pub struct SpringConfig {
    pub stiffness: f64,
    pub damping: f64,
    pub mass: f64,
}

pub fn simulate_spring(current: f64, target: f64, velocity: &mut f64, config: &SpringConfig, dt: f64) -> f64
```

### 5.2 Cursor Smoothing Algorithm

`src-tauri/src/processing/cursor_smooth.rs`:

- Read mouse moves from JSON
- Apply spring physics simulation
- Interpolate at output framerate
- Handle teleporting cursor detection
- Handle screen edge behavior

### 5.3 Smoothing UI

- Enable/disable toggle
- Intensity slider (adjusts spring params)
- Preview in editor

**Deliverable:** Smooth cursor in preview/export

---

## Phase 6: Automatic Zoom (Week 8)

**Goal:** Click-based automatic zoom

### 6.1 Zoom Algorithm

`src-tauri/src/processing/zoom.rs`:

- Click detection from JSON
- Click grouping by time/space proximity
- Zoom region calculation
- Edge snapping

### 6.2 Zoom Types

- `follow-cursor`: Track cursor position
- `follow-clicks`: Center on click locations
- `manual`: Fixed position

### 6.3 Zoom Transitions

- Spring physics for smooth zoom in/out
- Configurable zoom speed
- Instant zoom option

### 6.4 Zoom UI

- Timeline markers for zoom ranges
- Add/edit/delete zoom regions
- Zoom level control
- Zoom type selection

**Deliverable:** Automatic zoom working

---

## Phase 7: Basic Editor (Weeks 9-10)

**Goal:** Timeline-based editing

### 7.1 HLS Player Integration

- hls.js for segment playback
- Seek to any segment
- Frame-accurate playback control

### 7.2 Timeline Component

`src/components/editor/Timeline.tsx`:

- Visual timeline representation
- Segment thumbnails
- Playhead with time display
- Zoom in/out timeline view

### 7.3 Playback Controls

- Play/pause
- Seek (click on timeline)
- Frame step forward/backward
- Playback speed control

### 7.4 Trimming

- Adjust recording range (start/end trim)
- Visual trim handles
- Preview trimmed result

### 7.5 Cutting (Slices)

- Cut to create new slices
- Remove slices
- Reorder slices (future)

### 7.6 Undo/Redo System

- Command pattern for edits
- Zustand middleware or separate undo stack
- Keyboard shortcuts (Cmd/Ctrl+Z, Cmd/Ctrl+Shift+Z)

**Deliverable:** Basic non-destructive editing

---

## Phase 8: Layout System (Week 11)

**Goal:** Camera/screen arrangement

### 8.1 Layout Data Structure

```typescript
interface Layout {
  id: string;
  startTime: number;
  endTime: number;
  type: "screen-only" | "camera-only" | "screen-with-camera" | "side-by-side";
  cameraSize: number;
  cameraPosition: { x: number; y: number };
}
```

### 8.2 Layout Types

- `screen-only`: Full screen, no camera
- `camera-only`: Full camera, no screen
- `screen-with-camera`: Screen with camera overlay (PiP)
- `side-by-side`: Split view

### 8.3 Layout Transitions

- Animated transitions between layouts
- Configurable transition duration

### 8.4 Layout UI

- Layout preset buttons
- Camera position controls (drag or presets)
- Camera size slider
- Timeline keyframe markers

**Deliverable:** Configurable camera layouts

---

## Phase 9: Styling System (Week 12)

**Goal:** Backgrounds and visual polish

### 9.1 Background Options

- Solid colors
- Gradients (linear, radial)
- Images (stretch, fit, fill)

### 9.2 Visual Controls

- Padding/spacing (top, right, bottom, left)
- Corner radius
- Drop shadow (intensity, angle, distance, blur)
- Border

### 9.3 Styling UI

- Color pickers
- Gradient editor
- Padding sliders
- Shadow controls
- Real-time preview

**Deliverable:** Styled output

---

## Phase 10: Export System (Week 13)

**Goal:** Production-ready export

### 10.1 Export Pipeline

`src-tauri/src/export/`:

- Read all segments
- Apply effects (zoom, cursor smoothing, composition)
- Encode to output format

### 10.2 Compositor

`src-tauri/src/processing/compositor.rs`:

- Layer screen, camera, cursor
- Apply backgrounds
- Apply shadows, corners

### 10.3 FFmpeg Integration

`src-tauri/src/export/encoder.rs`:

- ffmpeg-next crate
- MP4 export (H.264/H.265)
- GIF export with optimization
- WebM export (VP9)

### 10.4 Export Presets

- Quality levels (low, medium, high, lossless)
- Resolution options
- Framerate options

### 10.5 Hardware Acceleration

- VideoToolbox (macOS)
- NVENC/AMD (Windows)
- Fallback to software encoding

### 10.6 Export UI

- Format selection
- Quality/preset selection
- Resolution picker
- Progress bar
- Cancel button
- Output file picker

**Deliverable:** Export polished videos

---

## Phase 11: Polish & MVP Release (Week 14)

**Goal:** Ship it!

### 11.1 Bug Fixes

- Edge case handling
- Error recovery
- Crash fixes

### 11.2 Performance Optimization

- Memory profiling
- CPU optimization
- Segment loading optimization

### 11.3 UI Polish

- Animations and transitions
- Loading states
- Error states
- Empty states

### 11.4 Documentation

- User guide
- Keyboard shortcuts reference
- FAQ

### 11.5 Release Builds

- macOS universal binary (Intel + Apple Silicon)
- Windows x64 installer
- Code signing (if certificates available)
- Auto-updater setup

**Deliverable:** MVP release v0.1.0

---

## Key Files to Create/Modify

### Phase 0 (Initial Setup)

- `package.json` - Create via Tauri CLI, add dependencies
- `src-tauri/Cargo.toml` - Add Rust dependencies
- `src-tauri/tauri.conf.json` - Configure Tauri app
- `tailwind.config.js` - Tailwind configuration
- `src/types/project.ts` - TypeScript types
- `src/App.tsx` - Main app with routing
- `src/stores/projectStore.ts` - Zustand project store
- `src-tauri/src/project/bundle.rs` - Project bundle I/O
- `src-tauri/src/commands/project.rs` - Tauri commands

### Phase 1-4 (Recording)

- `src-tauri/src/recorder/channel.rs` - Channel trait
- `src-tauri/src/recorder/coordinator.rs` - Recording coordinator
- `src-tauri/src/recorder/segment_writer.rs` - HLS segment writer
- `src-tauri/src/capture/macos/*.rs` - macOS capture implementations
- `src-tauri/src/capture/windows/*.rs` - Windows capture implementations
- `src/components/recording/RecordingView.tsx` - Recording UI

### Phase 5-6 (Processing)

- `src-tauri/src/processing/spring.rs` - Spring physics
- `src-tauri/src/processing/cursor_smooth.rs` - Cursor smoothing
- `src-tauri/src/processing/zoom.rs` - Automatic zoom

### Phase 7-9 (Editing)

- `src/components/editor/EditorView.tsx` - Editor main view
- `src/components/editor/Timeline.tsx` - Timeline component
- `src/components/editor/Preview.tsx` - Preview player
- `src/stores/editorStore.ts` - Editor state

### Phase 10-11 (Export)

- `src-tauri/src/export/encoder.rs` - FFmpeg encoding
- `src-tauri/src/processing/compositor.rs` - Layer composition
- `src/components/export/ExportView.tsx` - Export UI

---

## Verification Plan

### Phase 0 Verification - DONE

1. Run `bun run tauri:dev` - app opens with dark UI
2. Navigate between Record/Edit/Export views
3. Click "New" - creates project in memory
4. UI controls respond (source dropdown, toggles, buttons)

### Phase 1 Verification - PASSED

1. `bun run tauri:dev` - app opens ✓
2. Screen recording permission prompt appears on first record attempt (macOS) ✓
3. Display dropdown shows real system displays ✓
4. Start recording for 5+ seconds, then stop ✓
5. Check `/tmp/open-screenstudio-{timestamp}/recording-0.mp4` exists ✓
6. Play MP4 with QuickTime - video plays at full Retina resolution ✓

### Phase 2-4 Verification

1. Start recording - should create segment files
2. Stop recording - should have valid m3u8 playlist
3. Verify audio sync with video
4. Verify webcam recording

### Phase 5-6 Verification

1. Enable cursor smoothing - cursor should move smoothly in preview
2. Create zoom range - should zoom smoothly to target

### Phase 7-9 Verification

1. Open recorded project in editor
2. Trim, cut, and rearrange slices
3. Change layouts and styling
4. Preview changes in real-time

### Phase 10-11 Verification

1. Export to MP4 - verify playback in VLC
2. Export to GIF - verify animation
3. Verify all effects applied correctly
4. Test on both macOS and Windows

---

## Dependencies Summary

### Rust Crates (src-tauri/Cargo.toml) - ACTUAL

```toml
[dependencies]
# Tauri
tauri = { version = "2", features = ["macos-private-api"] }
tauri-plugin-shell = "2"
tauri-plugin-dialog = "2"
tauri-plugin-fs = "2"

# Async Runtime
tokio = { version = "1", features = ["full"] }

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Error Handling
thiserror = "1"
anyhow = "1"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Utilities
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
async-trait = "0.1"      # Async trait support
parking_lot = "0.12"     # Fast mutex for frame writing
tempfile = "3"           # Temp directory management

# Phase 2+ (planned)
# cpal = "0.15"          # Cross-platform audio I/O

[target.'cfg(target_os = "macos")'.dependencies]
objc2 = "0.5"
objc2-foundation = "0.2"
objc2-app-kit = "0.2"
block2 = "0.5"
core-foundation = "0.10"
core-graphics = "0.24"   # For CGDisplay::screenshot
cocoa = "0.26"
dispatch = "0.2"
# NOTE: Avoided screencapturekit crate due to Swift runtime issues

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = [
    "Win32_Foundation",
    "Win32_Graphics_Gdi",         # For BitBlt screen capture
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_LibraryLoader",
    # Phase 2+ for audio:
    # "Win32_Media_Audio",
    # "Win32_System_Com",
] }
```

### Bun Packages (package.json)

Managed with `bun install`:

```json
{
  "dependencies": {
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "zustand": "^4.5.0",
    "lucide-react": "^0.400.0",
    "@tauri-apps/api": "^2.0.0",
    "@tauri-apps/plugin-dialog": "^2.0.0",
    "@tauri-apps/plugin-fs": "^2.0.0"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2.0.0",
    "typescript": "^5.5.0",
    "vite": "^5.4.0",
    "@vitejs/plugin-react": "^4.3.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0"
  }
}
```

### System Dependencies

**macOS:**

```bash
brew install ffmpeg
```

**Windows:**

- FFmpeg binaries in PATH (download from ffmpeg.org)
- Or bundle FFmpeg with the app

### Key Architecture Decisions

1. **Shell out to FFmpeg CLI** instead of using `ffmpeg-next` crate
   - Simpler, more reliable
   - User's FFmpeg installation handles codec licensing
   - Pipe raw frames/samples via stdin

2. **Platform-specific capture APIs**
   - macOS: `core-graphics` CGDisplay (not ScreenCaptureKit)
   - Windows: GDI BitBlt (not Windows.Graphics.Capture)
   - Simpler, more compatible, fewer dependencies

3. **Separate files per channel**
   - `recording-{session}.mp4` for video
   - `recording-{session}-audio.m4a` for system audio (Phase 2)
   - `recording-{session}-mic.m4a` for microphone (Phase 2)
   - Combined in export phase
