# Open ScreenStudio - Full MVP Implementation Plan

## Overview

This plan covers the complete MVP implementation (Phases 0-11) for Open ScreenStudio, a Tauri + Rust screen recording application with React frontend. Development will target both macOS and Windows from the start.

**Timeline:** ~14 weeks as outlined in TECHNICAL_PLAN.md  
**Package Manager:** Bun (instead of npm for faster installs)  
**Reference:** `example-project.screenstudio/` contains sample project file format

---

## Phase 0: Project Setup (Week 1) - COMPLETED

**Status:** Done  
**Goal:** Working Tauri app with basic UI

### Learnings & Decisions

1. **Bun over npm** - Using Bun for package management (faster installs, native TypeScript)
   - `bun install` instead of `npm install`
   - Updated `tauri.conf.json` to use `bun run dev` / `bun run build`
   - CI workflows use `oven-sh/setup-bun@v2`

2. **Manual setup required** - `npm create tauri-app` fails on non-empty directories, so we created files manually

3. **Icons** - Created placeholder PNG icons with Python/PIL. Real icons needed before release.

4. **Rust dependencies** - Using latest versions:
   - `core-foundation = "0.10"` (not 0.9)
   - `core-graphics = "0.24"` (not 0.23)
   - `cocoa = "0.26"` for macOS UI integration

### What Was Created

**Frontend:**
- `src/App.tsx` - Main app with sidebar navigation
- `src/components/recording/RecordingView.tsx` - Recording UI with source selection, toggles
- `src/components/editor/EditorView.tsx` - Timeline editor placeholder
- `src/components/export/ExportView.tsx` - Export presets and settings
- `src/stores/projectStore.ts` - Zustand store for project state
- `src/types/project.ts` - Full TypeScript types matching .osp format

**Backend:**
- `src-tauri/src/lib.rs` - Tauri app initialization with plugins
- `src-tauri/src/commands/project.rs` - Project CRUD commands
- `src-tauri/src/commands/system.rs` - System info, display enumeration
- `src-tauri/src/project/schema.rs` - Rust types matching TS types
- `src-tauri/src/project/bundle.rs` - .osp bundle read/write
- `src-tauri/src/utils/error.rs` - Error handling

**Config:**
- `package.json` - Bun-compatible, all dependencies
- `src-tauri/Cargo.toml` - Platform-specific dependencies
- `src-tauri/tauri.conf.json` - Uses Bun commands
- `.github/workflows/ci.yml` - Uses Bun
- `.github/workflows/release.yml` - Uses Bun

### Verification
```bash
bun run tauri:dev  # App opens with working UI
```

---

## Phase 1: Multi-Channel Recording Infrastructure (Weeks 2-3) - NEXT

**Status:** Ready to implement  
**Goal:** Recording coordinator with screen capture (macOS + Windows in parallel)  
**Prerequisites:** FFmpeg installed (`brew install ffmpeg` on macOS)

### 1.1 Add FFmpeg Dependency
Need `ffmpeg-next` crate for video encoding. This requires FFmpeg installed on the system.

**macOS:**
```bash
brew install ffmpeg pkg-config
```

**Cargo.toml addition:**
```toml
ffmpeg-next = "7"
```

### 1.2 Create Recorder Module Structure
```
src-tauri/src/recorder/
├── mod.rs              # Module exports
├── channel.rs          # RecordingChannel trait
├── coordinator.rs      # RecordingCoordinator
├── state.rs            # RecordingState enum
└── segment_writer.rs   # HLS/fMP4 writer
```

### 1.3 Define Channel Trait
`src-tauri/src/recorder/channel.rs`:
```rust
use async_trait::async_trait;

#[async_trait]
pub trait RecordingChannel: Send + Sync {
    /// Channel identifier (e.g., "display", "audio", "webcam")
    fn id(&self) -> &str;
    
    /// Start recording
    async fn start(&mut self) -> Result<(), RecordingError>;
    
    /// Stop recording  
    async fn stop(&mut self) -> Result<(), RecordingError>;
    
    /// Pause recording (creates new session on resume)
    async fn pause(&mut self) -> Result<(), RecordingError>;
    
    /// Resume recording
    async fn resume(&mut self) -> Result<(), RecordingError>;
    
    /// Check if channel is currently recording
    fn is_recording(&self) -> bool;
}
```

### 1.4 Implement Recording Coordinator
`src-tauri/src/recorder/coordinator.rs`:
- Holds Vec<Box<dyn RecordingChannel>>
- Manages shared state: RecordingState (Idle, Recording, Paused)
- Session counter for pause/resume
- Output directory management
- Emits events to frontend via Tauri events

**Key methods:**
- `add_channel(channel: Box<dyn RecordingChannel>)`
- `start_recording(output_dir: PathBuf)` 
- `stop_recording() -> RecordingMetadata`
- `pause_recording()`
- `resume_recording()`

### 1.5 Implement Display Capture (macOS)
`src-tauri/src/capture/macos/screen.rs`:

**Dependencies needed:**
```toml
[target.'cfg(target_os = "macos")'.dependencies]
screencapturekit = "0.2"  # Or use objc2 bindings directly
```

**Or manual ScreenCaptureKit bindings:**
- Use `objc2` to call ScreenCaptureKit APIs
- `SCShareableContent::getShareableContentWithCompletionHandler`
- `SCStream` for frame capture
- `SCStreamConfiguration` for format settings

**Key flow:**
1. Request screen recording permission
2. Enumerate displays via `SCShareableContent`
3. Create `SCStream` with selected display
4. Receive frames via `SCStreamOutput` delegate
5. Encode frames to fMP4 segments

### 1.5b Implement Display Capture (Windows)
`src-tauri/src/capture/windows/screen.rs`:

**Using Windows.Graphics.Capture:**
```toml
[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = [
    "Graphics_Capture",
    "Graphics_DirectX_Direct3D11",
    "Win32_Graphics_Direct3D11",
    "Win32_System_WinRT_Direct3D11",
]}
```

**Key flow:**
1. Create `GraphicsCaptureItem` for display
2. Create `Direct3D11CaptureFramePool`
3. Start `GraphicsCaptureSession`
4. Receive frames via `FrameArrived` event
5. Convert D3D texture to raw pixels
6. Encode frames to fMP4 segments

### 1.6 Implement Segment Writer
`src-tauri/src/recorder/segment_writer.rs`:
- Create fMP4 init segment (moov box)
- Write media segments (~2s each)
- Update m3u8 playlist after each segment
- Use ffmpeg-next for encoding

**Segment naming:**
```
channel-display-0.m3u8
channel-display-0-0000.mp4  # init segment
channel-display-0-0001.m4s  # segment 1
channel-display-0-0002.m4s  # segment 2
```

### 1.7 Add Recording Tauri Commands
`src-tauri/src/commands/recording.rs`:
```rust
#[tauri::command]
async fn start_recording(state: State<'_, RecorderState>, config: RecordingConfig) -> Result<(), String>;

#[tauri::command]
async fn stop_recording(state: State<'_, RecorderState>) -> Result<RecordingResult, String>;

#[tauri::command]
async fn pause_recording(state: State<'_, RecorderState>) -> Result<(), String>;

#[tauri::command]
async fn resume_recording(state: State<'_, RecorderState>) -> Result<(), String>;

#[tauri::command]
async fn get_recording_state(state: State<'_, RecorderState>) -> Result<RecordingState, String>;
```

### 1.8 Connect Frontend to Backend
Update `src/components/recording/RecordingView.tsx`:
- Import `@tauri-apps/api/core` for invoke
- Call `invoke('get_displays')` to populate real display list
- Call `invoke('start_recording', { config })` on record button
- Listen to recording events for state updates
- Handle permission dialogs

### 1.9 Handle Permissions (macOS)
- Check `CGPreflightScreenCaptureAccess()` 
- Request with `CGRequestScreenCaptureAccess()`
- Show user-friendly message if denied
- Link to System Preferences

### Files to Create/Modify

**New files:**
- `src-tauri/src/recorder/mod.rs`
- `src-tauri/src/recorder/channel.rs`
- `src-tauri/src/recorder/coordinator.rs`
- `src-tauri/src/recorder/state.rs`
- `src-tauri/src/recorder/segment_writer.rs`
- `src-tauri/src/capture/mod.rs`
- `src-tauri/src/capture/traits.rs`
- `src-tauri/src/capture/macos/mod.rs`
- `src-tauri/src/capture/macos/screen.rs`
- `src-tauri/src/capture/macos/permissions.rs`
- `src-tauri/src/capture/windows/mod.rs`
- `src-tauri/src/capture/windows/screen.rs`
- `src-tauri/src/commands/recording.rs`

**Modified files:**
- `src-tauri/src/lib.rs` - Add recorder module, recording commands
- `src-tauri/Cargo.toml` - Add ffmpeg-next, async-trait
- `src/components/recording/RecordingView.tsx` - Connect to Tauri
- `src/stores/projectStore.ts` - Add recording state

### Verification

1. **Permission check:**
   ```bash
   bun run tauri:dev
   # Click "Start Recording" - should prompt for screen recording permission
   ```

2. **Display enumeration:**
   - Dropdown should show real displays from system
   
3. **Recording test:**
   - Start recording for 5 seconds
   - Stop recording
   - Check output directory for:
     - `channel-display-0.m3u8`
     - `channel-display-0-0000.mp4`
     - `channel-display-0-0001.m4s` (etc.)
   - Play m3u8 with VLC to verify video

**Deliverable:** Can record screen to segmented fMP4 on macOS and Windows

---

## Phase 2: Audio Channels (Week 4)

**Goal:** Add audio recording channels

### 2.1 macOS Audio
- System audio via ScreenCaptureKit (SCStreamConfiguration)
- Microphone via AVFoundation (AVAudioEngine)

### 2.2 Windows Audio
- System audio via WASAPI loopback capture
- Microphone via WASAPI standard capture

### 2.3 Audio/Video Sync
- Common timestamp reference (process time)
- Sync segments across channels

### 2.4 Audio UI
- Audio source selection (mic, system)
- Audio level meters
- Mute controls

**Deliverable:** Record screen with synced audio

---

## Phase 3: Input Tracking Channel (Week 5)

**Goal:** High-frequency input capture

### 3.1 Input Data Structures
```rust
pub struct MouseMove {
    pub x: f64,
    pub y: f64,
    pub cursor_id: String,
    pub active_modifiers: Vec<String>,
    pub process_time_ms: f64,
    pub unix_time_ms: u64,
}
```

### 3.2 macOS Input Tracking
- CGEvent for mouse position (~120Hz)
- CGEvent for keyboard events
- CGDisplayCopyCurrentCursor for cursor images

### 3.3 Windows Input Tracking
- GetCursorPos for mouse position
- SetWindowsHookEx for keyboard
- GetCursorInfo for cursor images

### 3.4 JSON Buffer & Flush
- Buffer input events in memory
- Periodic flush to JSON files
- Final flush on recording stop

### 3.5 Cursor Image Capture
- Capture unique cursor images as PNG
- Store cursor metadata (hotspot, size)
- Reference by cursor_id

**Deliverable:** Full input tracking during recording

---

## Phase 4: Webcam Channel (Week 6)

**Goal:** Camera recording

### 4.1 macOS Webcam
- AVFoundation AVCaptureSession
- Device enumeration
- Frame capture to fMP4 segments

### 4.2 Windows Webcam
- Windows.Media.Capture MediaCapture
- Device enumeration
- Frame capture

### 4.3 Webcam UI
- Camera preview overlay
- Device selection dropdown
- Enable/disable toggle
- Mirror option

**Deliverable:** Record with webcam overlay

---

## Phase 5: Cursor Smoothing (Week 7)

**Goal:** Smooth cursor movement in playback

### 5.1 Spring Physics Implementation
`src-tauri/src/processing/spring.rs`:
```rust
pub struct SpringConfig {
    pub stiffness: f64,
    pub damping: f64,
    pub mass: f64,
}

pub fn simulate_spring(current: f64, target: f64, velocity: &mut f64, config: &SpringConfig, dt: f64) -> f64
```

### 5.2 Cursor Smoothing Algorithm
`src-tauri/src/processing/cursor_smooth.rs`:
- Read mouse moves from JSON
- Apply spring physics simulation
- Interpolate at output framerate
- Handle teleporting cursor detection
- Handle screen edge behavior

### 5.3 Smoothing UI
- Enable/disable toggle
- Intensity slider (adjusts spring params)
- Preview in editor

**Deliverable:** Smooth cursor in preview/export

---

## Phase 6: Automatic Zoom (Week 8)

**Goal:** Click-based automatic zoom

### 6.1 Zoom Algorithm
`src-tauri/src/processing/zoom.rs`:
- Click detection from JSON
- Click grouping by time/space proximity
- Zoom region calculation
- Edge snapping

### 6.2 Zoom Types
- `follow-cursor`: Track cursor position
- `follow-clicks`: Center on click locations
- `manual`: Fixed position

### 6.3 Zoom Transitions
- Spring physics for smooth zoom in/out
- Configurable zoom speed
- Instant zoom option

### 6.4 Zoom UI
- Timeline markers for zoom ranges
- Add/edit/delete zoom regions
- Zoom level control
- Zoom type selection

**Deliverable:** Automatic zoom working

---

## Phase 7: Basic Editor (Weeks 9-10)

**Goal:** Timeline-based editing

### 7.1 HLS Player Integration
- hls.js for segment playback
- Seek to any segment
- Frame-accurate playback control

### 7.2 Timeline Component
`src/components/editor/Timeline.tsx`:
- Visual timeline representation
- Segment thumbnails
- Playhead with time display
- Zoom in/out timeline view

### 7.3 Playback Controls
- Play/pause
- Seek (click on timeline)
- Frame step forward/backward
- Playback speed control

### 7.4 Trimming
- Adjust recording range (start/end trim)
- Visual trim handles
- Preview trimmed result

### 7.5 Cutting (Slices)
- Cut to create new slices
- Remove slices
- Reorder slices (future)

### 7.6 Undo/Redo System
- Command pattern for edits
- Zustand middleware or separate undo stack
- Keyboard shortcuts (Cmd/Ctrl+Z, Cmd/Ctrl+Shift+Z)

**Deliverable:** Basic non-destructive editing

---

## Phase 8: Layout System (Week 11)

**Goal:** Camera/screen arrangement

### 8.1 Layout Data Structure
```typescript
interface Layout {
  id: string;
  startTime: number;
  endTime: number;
  type: 'screen-only' | 'camera-only' | 'screen-with-camera' | 'side-by-side';
  cameraSize: number;
  cameraPosition: { x: number; y: number };
}
```

### 8.2 Layout Types
- `screen-only`: Full screen, no camera
- `camera-only`: Full camera, no screen
- `screen-with-camera`: Screen with camera overlay (PiP)
- `side-by-side`: Split view

### 8.3 Layout Transitions
- Animated transitions between layouts
- Configurable transition duration

### 8.4 Layout UI
- Layout preset buttons
- Camera position controls (drag or presets)
- Camera size slider
- Timeline keyframe markers

**Deliverable:** Configurable camera layouts

---

## Phase 9: Styling System (Week 12)

**Goal:** Backgrounds and visual polish

### 9.1 Background Options
- Solid colors
- Gradients (linear, radial)
- Images (stretch, fit, fill)

### 9.2 Visual Controls
- Padding/spacing (top, right, bottom, left)
- Corner radius
- Drop shadow (intensity, angle, distance, blur)
- Border

### 9.3 Styling UI
- Color pickers
- Gradient editor
- Padding sliders
- Shadow controls
- Real-time preview

**Deliverable:** Styled output

---

## Phase 10: Export System (Week 13)

**Goal:** Production-ready export

### 10.1 Export Pipeline
`src-tauri/src/export/`:
- Read all segments
- Apply effects (zoom, cursor smoothing, composition)
- Encode to output format

### 10.2 Compositor
`src-tauri/src/processing/compositor.rs`:
- Layer screen, camera, cursor
- Apply backgrounds
- Apply shadows, corners

### 10.3 FFmpeg Integration
`src-tauri/src/export/encoder.rs`:
- ffmpeg-next crate
- MP4 export (H.264/H.265)
- GIF export with optimization
- WebM export (VP9)

### 10.4 Export Presets
- Quality levels (low, medium, high, lossless)
- Resolution options
- Framerate options

### 10.5 Hardware Acceleration
- VideoToolbox (macOS)
- NVENC/AMD (Windows)
- Fallback to software encoding

### 10.6 Export UI
- Format selection
- Quality/preset selection
- Resolution picker
- Progress bar
- Cancel button
- Output file picker

**Deliverable:** Export polished videos

---

## Phase 11: Polish & MVP Release (Week 14)

**Goal:** Ship it!

### 11.1 Bug Fixes
- Edge case handling
- Error recovery
- Crash fixes

### 11.2 Performance Optimization
- Memory profiling
- CPU optimization
- Segment loading optimization

### 11.3 UI Polish
- Animations and transitions
- Loading states
- Error states
- Empty states

### 11.4 Documentation
- User guide
- Keyboard shortcuts reference
- FAQ

### 11.5 Release Builds
- macOS universal binary (Intel + Apple Silicon)
- Windows x64 installer
- Code signing (if certificates available)
- Auto-updater setup

**Deliverable:** MVP release v0.1.0

---

## Key Files to Create/Modify

### Phase 0 (Initial Setup)
- `package.json` - Create via Tauri CLI, add dependencies
- `src-tauri/Cargo.toml` - Add Rust dependencies
- `src-tauri/tauri.conf.json` - Configure Tauri app
- `tailwind.config.js` - Tailwind configuration
- `src/types/project.ts` - TypeScript types
- `src/App.tsx` - Main app with routing
- `src/stores/projectStore.ts` - Zustand project store
- `src-tauri/src/project/bundle.rs` - Project bundle I/O
- `src-tauri/src/commands/project.rs` - Tauri commands

### Phase 1-4 (Recording)
- `src-tauri/src/recorder/channel.rs` - Channel trait
- `src-tauri/src/recorder/coordinator.rs` - Recording coordinator
- `src-tauri/src/recorder/segment_writer.rs` - HLS segment writer
- `src-tauri/src/capture/macos/*.rs` - macOS capture implementations
- `src-tauri/src/capture/windows/*.rs` - Windows capture implementations
- `src/components/recording/RecordingView.tsx` - Recording UI

### Phase 5-6 (Processing)
- `src-tauri/src/processing/spring.rs` - Spring physics
- `src-tauri/src/processing/cursor_smooth.rs` - Cursor smoothing
- `src-tauri/src/processing/zoom.rs` - Automatic zoom

### Phase 7-9 (Editing)
- `src/components/editor/EditorView.tsx` - Editor main view
- `src/components/editor/Timeline.tsx` - Timeline component
- `src/components/editor/Preview.tsx` - Preview player
- `src/stores/editorStore.ts` - Editor state

### Phase 10-11 (Export)
- `src-tauri/src/export/encoder.rs` - FFmpeg encoding
- `src-tauri/src/processing/compositor.rs` - Layer composition
- `src/components/export/ExportView.tsx` - Export UI

---

## Verification Plan

### Phase 0 Verification - DONE
1. Run `bun run tauri:dev` - app opens with dark UI
2. Navigate between Record/Edit/Export views
3. Click "New" - creates project in memory
4. UI controls respond (source dropdown, toggles, buttons)

### Phase 1 Verification
1. `bun run tauri:dev` - app opens
2. Screen recording permission prompt appears on first record attempt (macOS)
3. Display dropdown shows real system displays
4. Start recording for 5+ seconds, then stop
5. Check output folder contains `.m3u8` and `.m4s` segment files
6. Play `.m3u8` with VLC - video should play correctly

### Phase 2-4 Verification
1. Start recording - should create segment files
2. Stop recording - should have valid m3u8 playlist
3. Verify audio sync with video
4. Verify webcam recording

### Phase 5-6 Verification
1. Enable cursor smoothing - cursor should move smoothly in preview
2. Create zoom range - should zoom smoothly to target

### Phase 7-9 Verification
1. Open recorded project in editor
2. Trim, cut, and rearrange slices
3. Change layouts and styling
4. Preview changes in real-time

### Phase 10-11 Verification
1. Export to MP4 - verify playback in VLC
2. Export to GIF - verify animation
3. Verify all effects applied correctly
4. Test on both macOS and Windows

---

## Dependencies Summary

### Rust Crates (src-tauri/Cargo.toml)
```toml
[dependencies]
tauri = { version = "2", features = ["macos-private-api"] }
tauri-plugin-shell = "2"
tauri-plugin-dialog = "2"
tauri-plugin-fs = "2"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"
anyhow = "1"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

# Phase 1+
ffmpeg-next = "7"        # Video encoding (requires FFmpeg installed)
async-trait = "0.1"      # Async trait support
image = "0.25"           # Image processing

[target.'cfg(target_os = "macos")'.dependencies]
objc2 = "0.5"
block2 = "0.5"
core-foundation = "0.10"
core-graphics = "0.24"
cocoa = "0.26"

[target.'cfg(target_os = "windows")'.dependencies]
windows = { version = "0.58", features = ["Graphics_Capture", "Win32_System_WinRT", "Win32_UI_WindowsAndMessaging", "Media_Audio", "Media_Capture"] }
```

### Bun Packages (package.json)
Managed with `bun install`:
```json
{
  "dependencies": {
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "zustand": "^4.5.0",
    "hls.js": "^1.5.0",
    "lucide-react": "^0.400.0",
    "@tauri-apps/api": "^2.0.0",
    "@tauri-apps/plugin-dialog": "^2.0.0",
    "@tauri-apps/plugin-fs": "^2.0.0"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2.0.0",
    "typescript": "^5.5.0",
    "vite": "^5.4.0",
    "@vitejs/plugin-react": "^4.3.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0"
  }
}
```

### System Dependencies (Phase 1)
**macOS:**
```bash
brew install ffmpeg pkg-config
```

**Windows:**
- FFmpeg binaries in PATH or bundled
